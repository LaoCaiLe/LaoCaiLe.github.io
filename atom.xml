<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HEXO</title>
  
  
  <link href="http://laocaile.github.io/atom.xml" rel="self"/>
  
  <link href="http://laocaile.github.io/"/>
  <updated>2024-01-21T13:43:54.459Z</updated>
  <id>http://laocaile.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Note Record</title>
    <link href="http://laocaile.github.io/2024/01/21/test-file/"/>
    <id>http://laocaile.github.io/2024/01/21/test-file/</id>
    <published>2024-01-21T13:24:52.281Z</published>
    <updated>2024-01-21T13:43:54.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-C"><a href="#C-C" class="headerlink" title="C&#x2F;C++"></a>C&#x2F;C++</h1><h3 id="1、描述⼀下gcc的编译过程？"><a href="#1、描述⼀下gcc的编译过程？" class="headerlink" title="1、描述⼀下gcc的编译过程？"></a><strong>1、描述⼀下gcc的编译过程？</strong></h3><blockquote><p>gcc编译过程分为4个阶段：预处理、编译、汇编、链接。</p><p>预处理：头⽂件&#x2F;、宏替换、条件编译、删除注释  gcc -E<br>编译：主要进⾏词法、语法、语义分析等，检查⽆误后将预处理好的⽂件编译成汇编⽂件。 gcc -S<br>汇编：将汇编⽂件转换成 ⼆进制⽬标⽂件gcc -c<br>链接：将项⽬中的各个⼆进制⽂件+所需的库+启动代码链接成可执⾏⽂件 无参数</p><p>链接时会发生地址回填和数据段合并 .text 和.rodata合并成代码区 .data和.bss 合并成全局区（大概是这个意思）</p></blockquote><h3 id="2、内存的最⼩存储单位以及内存的最⼩计量单位分别是？"><a href="#2、内存的最⼩存储单位以及内存的最⼩计量单位分别是？" class="headerlink" title="2、内存的最⼩存储单位以及内存的最⼩计量单位分别是？"></a><strong>2、内存的最⼩存储单位以及内存的最⼩计量单位分别是？</strong></h3><blockquote><p>内存的最⼩存储单位为 <strong>二进制位</strong>， 内存的最⼩计量单位 <strong>字节</strong></p></blockquote><h3 id="3、-include-与-include-“”的区别？"><a href="#3、-include-与-include-“”的区别？" class="headerlink" title="3、#include&lt;&gt; 与#include “”的区别？"></a><strong>3、#include&lt;&gt; 与#include “”的区别？</strong></h3><blockquote><p>include&lt;&gt;到系统指定⽬录寻找头⽂件，#include “”先到项⽬所在⽬录寻找头⽂件，如果没有找再到系统指定的⽬录下寻找</p></blockquote><h3 id="4、描述⼀下变量的命名规则"><a href="#4、描述⼀下变量的命名规则" class="headerlink" title="4、描述⼀下变量的命名规则"></a><strong>4</strong>、<strong>描述⼀下变量的命名规则</strong></h3><blockquote><p>变量名有字⺟、数值、下划线组成，但不能以数值开头</p></blockquote><h3 id="5、变量的声明与定义有啥区别？"><a href="#5、变量的声明与定义有啥区别？" class="headerlink" title="5、变量的声明与定义有啥区别？"></a><strong>5、变量的声明与定义有啥区别？</strong></h3><blockquote><p>声明变量 不需要 建⽴存储空间， 变量的定义需要建⽴存储空间</p></blockquote><h3 id="6、谈谈c语⾔中有符号和⽆符号的区别？"><a href="#6、谈谈c语⾔中有符号和⽆符号的区别？" class="headerlink" title="6、谈谈c语⾔中有符号和⽆符号的区别？"></a><strong>6、谈谈c语⾔中有符号和⽆符号的区别？</strong></h3><blockquote><p>有符号：数据的最⾼位为符号位，0表示正数，1表示负数<br>⽆符号：数据的最⾼位不是符号位，⽽是数据的⼀部分</p></blockquote><h3 id="7、谈谈计算机中补码的意义"><a href="#7、谈谈计算机中补码的意义" class="headerlink" title="7、谈谈计算机中补码的意义"></a><strong>7、谈谈计算机中补码的意义</strong></h3><blockquote><p>统⼀了零的编码<br>将符号位与其他位统⼀处理将减法运算转换成加法运算</p></blockquote><h3 id="8、谈谈数组的特点"><a href="#8、谈谈数组的特点" class="headerlink" title="8、谈谈数组的特点"></a><strong>8、谈谈数组的特点</strong></h3><blockquote><p>同⼀个数组所有的成员都是相同的数据类型，同时所有的成员在内存中的地址是连续的</p></blockquote><h3 id="9、数组的分类"><a href="#9、数组的分类" class="headerlink" title="9、数组的分类"></a><strong>9</strong>、<strong>数组的分类</strong></h3><blockquote><p>数组的分类主要是：静态数组、动态数组两类。<br>静态数组：类似int arr[5];在程序运⾏就确定了数组的⼤⼩，运⾏过程不能更改数组的⼤⼩。<br>动态数组：主要是在堆区申请的空间，数组的⼤⼩是在程序运⾏过程中确定，可以更改数组的⼤⼩。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[i]; <span class="comment">//错误 因为在编译阶段，编译器并不知道 i 的值是多少</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size=<span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> *p=<span class="keyword">new</span> <span class="type">int</span>[size]; <span class="comment">//是正确的 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组 C</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **array <span class="comment">// array[M][N]</span></span><br><span class="line">array = (<span class="type">int</span> **)<span class="built_in">malloc</span>(M * <span class="built_in">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">    array[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(N * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++)</span><br><span class="line">    <span class="built_in">free</span>(array[i]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组 C++</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> **array <span class="comment">// array[M][N]</span></span><br><span class="line">array = <span class="keyword">new</span> <span class="type">int</span>*[M];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) </span><br><span class="line">    array[i] = <span class="keyword">new</span> <span class="type">int</span>[N]</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 释放</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; M; i++) </span><br><span class="line"> <span class="keyword">delete</span> [] array[i];</span><br><span class="line">   <span class="keyword">delete</span> [] array;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="10、描述⼀下⼀维数组的不初始化、部分初始化、完全初-始化的不同点"><a href="#10、描述⼀下⼀维数组的不初始化、部分初始化、完全初-始化的不同点" class="headerlink" title="10、描述⼀下⼀维数组的不初始化、部分初始化、完全初 始化的不同点"></a><strong>10</strong>、<strong>描述⼀下⼀维数组的不初始化、部分初始化、完全初</strong> <strong>始化的不同点</strong></h3><blockquote><p>不初始化：如果是局部数组 数组元素的内容随机 ；如果是全局数组，数组的元素内容为0<br>部分初始化：未被初始化的部分⾃动补0<br>完全初始化：如果⼀个数组全部初始化，可以省略元素的个数，数组的⼤⼩由初始化的个数确定</p></blockquote><h3 id="11、谈谈数组名作为类型、作为地址、对数组名取地址的区别？"><a href="#11、谈谈数组名作为类型、作为地址、对数组名取地址的区别？" class="headerlink" title="11、谈谈数组名作为类型、作为地址、对数组名取地址的区别？"></a><strong>11、谈谈数组名作为类型、作为地址、对数组名取地址的区别？</strong></h3><blockquote><p>数组名作为类型：代表的是整个数组的⼤⼩<br>数组名作为地址：代表的是数组⾸元素的地址<br>对数组名取地址：代表的是数组的⾸地址</p></blockquote><h3 id="12、谈谈你对⼆维数组在物理上以及逻辑上的数组维度理解"><a href="#12、谈谈你对⼆维数组在物理上以及逻辑上的数组维度理解" class="headerlink" title="12、谈谈你对⼆维数组在物理上以及逻辑上的数组维度理解"></a><strong>12、谈谈你对⼆维数组在物理上以及逻辑上的数组维度理解</strong></h3><blockquote><p>⼆维数组在逻辑上是⼆维的，在物理上是⼀维的</p></blockquote><h3 id="13、描述⼀下函数的定义与函数的声明的区别"><a href="#13、描述⼀下函数的定义与函数的声明的区别" class="headerlink" title="13、描述⼀下函数的定义与函数的声明的区别"></a><strong>13、描述⼀下函数的定义与函数的声明的区别</strong></h3><blockquote><p>函数定义：是指对函数功能的确⽴，包括指定函数名、函数类型、形参及其类型、函数体等，它是⼀个完整的、独⽴的函数单位。<br>函数的声明：是把函数的名字、函数类型以及形参的个数、类型和顺序(注意，不包括函数体)通知编译系统，以便在对包含函数调⽤的语句进⾏编译时，据此对其进⾏对照检查（例如函数名是否正确，实参与形参的类型和个数是否⼀致）</p></blockquote><h3 id="14、描述⼀下指针与指针变量的区别"><a href="#14、描述⼀下指针与指针变量的区别" class="headerlink" title="14、描述⼀下指针与指针变量的区别"></a><strong>14、描述⼀下指针与指针变量的区别</strong></h3><blockquote><p>指针：没存中每⼀个字节都会分配⼀个32位或64位的编号，这个编号就是地址, ⽽指针就是内存单元的编号。<br>指针变量：本质是变量 只是该变量存放的是空间的地址编号</p></blockquote><h3 id="15、描述⼀下32位或64位平台下指针的⼤⼩"><a href="#15、描述⼀下32位或64位平台下指针的⼤⼩" class="headerlink" title="15、描述⼀下32位或64位平台下指针的⼤⼩"></a><strong>15、描述⼀下32位或64位平台下指针的⼤⼩</strong></h3><blockquote><p>32位平台：任意类型的指针⼤⼩为4字节<br>64位平台：任意类型的指针⼤⼩为8字节</p></blockquote><h3 id="16、描述⼀下指针数组的概念"><a href="#16、描述⼀下指针数组的概念" class="headerlink" title="16、描述⼀下指针数组的概念"></a><strong>16、描述⼀下指针数组的概念</strong></h3><blockquote><p>指针数组本质是数组，只是数组的每个元素是⼀个指针（地址）</p></blockquote><h3 id="17、普通局部变量、普通全局变量、静态局部变量、静态全局变量的区别"><a href="#17、普通局部变量、普通全局变量、静态局部变量、静态全局变量的区别" class="headerlink" title="17、普通局部变量、普通全局变量、静态局部变量、静态全局变量的区别"></a><strong>17</strong>、<strong>普通局部变量、普通全局变量、静态局部变量、静态全局变量的区别</strong></h3><blockquote><p>**普通局部变量： **存在栈区、不初始化内容随机、只在定义所在的复合语句中有效、符合语句结束变量空间释放<br><strong>普通全局变量：</strong>存在全局区、不初始化内容为0、进程结束空间才被释放，能被当前源⽂件或其他源⽂件使⽤，只是其他源⽂件使⽤的时候，记得使⽤extern修饰<br><strong>静态局部变量：</strong> 存在全局区、不初始化内容为0、整个进程结束空间才被释放，只能在定义所在的复合语句中有效<br><strong>静态全局变量：</strong>存在全局区、不初始化内容为0、整个进程结束空间才被释放，只能被当前源⽂件使⽤</p></blockquote><h3 id="18、内存分区"><a href="#18、内存分区" class="headerlink" title="18、内存分区"></a><strong>18、内存分区</strong></h3><blockquote><p>程序在运⾏前：分为代码区、BSS段（未初始化数据区）、data段(初始化数据区)<br>程序在运⾏后：堆区、栈区、全局区（静态区）、⽂字常量区、代码区</p><p>&#x2F;&#x2F;全局区和代码区在程序运行前就已经存在了，栈区，堆区在程序运行后才有</p><p>栈：从大(地址)到小(地址)；</p><p>堆：从小(地址)到大(地址)；</p></blockquote><p>​ <strong>18.1 程序运行前 – Data段和BSS段</strong></p><blockquote><p>DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。</p></blockquote><p>​<strong>18.2 程序运行后 – 内存四区</strong></p><blockquote><p>&lt;– 栈区 –&gt; (临时区,当函数执行完毕的时候,自动释放)<br>由编译器自动分配释放, 存放函数的参数值,局部变量,局部常量等. </p><p>&lt;– 堆区–&gt;（需要及时释放,可能会内存泄漏）<br>一般由程序员分配释放(动态内存申请与释放),若程序员不释放,程序结束时可能由操作系统回收</p><p>&lt;– 全局区 –&gt; (静态区)<br>全局变量和静态变量存放在此. 里面细分有一个常量区, 字符串常量和其他常量（除了局部常量）也存放在此. 该区域是在程序结束后由操作系统释放.</p><p>&lt;– 代码区 –&gt;(主要是指函数，不由我们关心，是交给操作系统托管的)<br>这个区域存放函数体的二进制代码.是由操作系统进行管理的·</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b; <span class="comment">//栈区</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//栈区</span></span><br><span class="line">    <span class="type">char</span> *p2;<span class="comment">//栈区</span></span><br><span class="line">    <span class="type">char</span> *p3 = <span class="string">&quot;123456&quot;</span>;<span class="comment">//p3在栈区，123456/0在文字常量区（全局区）</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>;<span class="comment">//静态初始化区（全局区）</span></span><br><span class="line">    p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);<span class="comment">//分配得来的10和20字节得区域就在堆区。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1,<span class="string">&quot;123456&quot;</span>);<span class="comment">// 123456/0放在常量区，编译器可能会将它与p3所指向得&quot;123456&quot;优化成一个地方。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="19、在使⽤realloc给已分配的堆区空间追加空间时需要注意啥？"><a href="#19、在使⽤realloc给已分配的堆区空间追加空间时需要注意啥？" class="headerlink" title="19、在使⽤realloc给已分配的堆区空间追加空间时需要注意啥？"></a><strong>19</strong>、<strong>在使⽤realloc给已分配的堆区空间追加空间时需要注意啥？</strong></h3><blockquote><p>记得⽤指针变量保存realloc的返回值</p></blockquote><h3 id="20、结构体与共⽤体的区别是啥"><a href="#20、结构体与共⽤体的区别是啥" class="headerlink" title="20、结构体与共⽤体的区别是啥"></a><strong>20</strong>、<strong>结构体与共⽤体的区别是啥</strong></h3><blockquote><p>结构体中的成员拥有独⽴的空间，共⽤体的成员共享同⼀块空间，但是每个共⽤体成员能访问共⽤区的空间⼤⼩是由成员⾃身的类型决定</p></blockquote><h3 id="21、谈谈⽂件的分类"><a href="#21、谈谈⽂件的分类" class="headerlink" title="21、谈谈⽂件的分类"></a><strong>21</strong>、<strong>谈谈⽂件的分类</strong></h3><blockquote><p>⽂件分为⼆进制和⽂本⽂件<br>⼆进制⽂件基于值编码，需要根据具体的应⽤才能知道某个值具体的含义<br>⽂本⽂件基于字符编码，⼀个字节⼀个意思，可以通过记事本打开</p></blockquote><h3 id="22、⽂件缓冲区刷新⽅式有⼏种"><a href="#22、⽂件缓冲区刷新⽅式有⼏种" class="headerlink" title="22、⽂件缓冲区刷新⽅式有⼏种"></a><strong>22</strong>、<strong>⽂件缓冲区刷新⽅式有⼏种</strong></h3><blockquote><p>⾏刷新、满刷新、强制刷新、关闭刷新</p></blockquote><h3 id="23、野指针"><a href="#23、野指针" class="headerlink" title="23、野指针"></a><strong>23、野指针</strong></h3><blockquote><ul><li>指针变量中的值是非法的内存地址，进而形成野指针</li><li>野指针不是NULL指针，是指向不可用内存地址的指针</li><li>NULL指针并无危害，很好判断，也很好调试</li><li>C语言中无法判断一个指针所保存的地址是否合法，合法的地址是通过变量或者malloc来申请的</li></ul><p><strong>野指针的由来</strong></p><ul><li><p>局部指针变量没有被初始化</p></li><li><p>指针所指向的变量在指针之前被销毁（如返回局部变量的地址或局部数组）</p></li><li><p>使用已经释放过的指针</p></li><li><p>进行了错误的指针运算</p></li><li><p>进行了错误的强制类型转换</p><p><strong>设计指针基本原则(避免野指针)</strong></p><p>   1、绝不返回局部变量的地址</p><p>   2、任何变量在定义后必须0初始化</p><p>   3、字符数组必须确认0结束符后才能成为字符串</p><p>   4、任何使用与内存操作相关的函数必须指定长度信息</p><p><strong>使用规则</strong></p><p>检查malloc返回值</p><p>free后置空</p><p>malloc和free成对出现</p></li></ul></blockquote><h3 id="24、如何理解指针作为函数参数的输⼊和输出特性"><a href="#24、如何理解指针作为函数参数的输⼊和输出特性" class="headerlink" title="24、如何理解指针作为函数参数的输⼊和输出特性"></a><strong>24</strong>、<strong>如何理解指针作为函数参数的输⼊和输出特性</strong></h3><blockquote><p>输⼊特性：主调函数分配空间 背调函数使⽤该空间<br>输出特性：被调⽤分配空间 主调函数使⽤该空间</p></blockquote><h3 id="25、如何理解结构体的浅拷⻉与深拷⻉"><a href="#25、如何理解结构体的浅拷⻉与深拷⻉" class="headerlink" title="25、如何理解结构体的浅拷⻉与深拷⻉"></a><strong>25</strong>、<strong>如何理解结构体的浅拷⻉与深拷⻉</strong></h3><blockquote><p>当结构体中有指针成员的时候容易出现浅拷⻉与深拷⻉的问题。<br>浅拷⻉就是，两个结构体变量的指针成员<strong>指向同⼀块堆区空间</strong>，在各个结构体变量释放的时候会出现多次释放同⼀段堆区空间<br>深拷⻉就是，让两个结构体变量的指针成员分别<strong>指向不同的堆区空间</strong>，只是空间内容拷⻉⼀份，这样在各个结构体变量释放的时候就不会出现多次释放同⼀段堆区空间的问题</p></blockquote><h3 id="26、结构体对⻬规则"><a href="#26、结构体对⻬规则" class="headerlink" title="26、结构体对⻬规则"></a>26、结构体对⻬规则</h3><blockquote><p>\1. 数组成员对⻬规则。第⼀个数组成员应该放在offset为0的地⽅，以后每个数组成员应该放在offset 为min（当前成员的⼤⼩，#pargama pack(n)）整数倍的地⽅开始（⽐如int在32位机器为４字节，#pargama pack(2)，那么从2的倍数地⽅开始存储）。<br>\2. 结构体总的⼤⼩，也就是sizeof的结果，必须是min（结构体内部最⼤成员，#pargama pack(n)）的整数倍，不⾜要补⻬。<br>\3. 结构体做为成员的对⻬规则。如果⼀个结构体B⾥嵌套另⼀个结构体A,还是以最⼤成员类型的⼤⼩对⻬，但是结构体A的起点为A内部最⼤成员的整数倍的地⽅。（struct B⾥存有struct A，A⾥有 char，int，double等成员，那A应该从8的整数倍开始存储。），结构体A中的成员的对⻬规则仍 满⾜原则1、原则2。</p><p>(64位编译器下：指针8字节)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行整体对齐，最大类型为1&lt;对齐系数4，按1整体对齐，所以1+1+1=3 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="type">char</span> a; <span class="comment">//1</span></span><br><span class="line"><span class="type">char</span> b; <span class="comment">//1</span></span><br><span class="line"><span class="type">char</span> c; <span class="comment">//1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行整体对齐，最大类型为4=对齐系数4，所以按4整体对齐4 1+2=3&lt;4 对齐4 所以4+4=8 </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;  <span class="comment">//4</span></span><br><span class="line">    <span class="type">char</span> b; <span class="comment">//1</span></span><br><span class="line">    <span class="type">short</span> c;<span class="comment">//2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行整体对齐，最大类型为4=对齐系数4，所以按4整体对齐 1&lt;4（对齐4） 4=4 2&lt;4(对齐4)  所以4+4+4=12</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> b; <span class="comment">//1</span></span><br><span class="line">    <span class="type">int</span> a;  <span class="comment">//4  </span></span><br><span class="line">    <span class="type">short</span> c;<span class="comment">//2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进行整体对齐，最大类型为4&gt;对齐系数n(2)，所以按2整体对齐 1&lt;2（对齐2）4&gt;2(2的倍数) 2=2 所以2+4+2=8 </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(2)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> &#123;</span></span><br><span class="line"><span class="type">char</span> b; <span class="comment">//1</span></span><br><span class="line"><span class="type">int</span> a;  <span class="comment">//4</span></span><br><span class="line"><span class="type">short</span> c;<span class="comment">//2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*************</span></span><br><span class="line"><span class="comment">19+11=30&lt;32bit     4</span></span><br><span class="line"><span class="comment">4+29=33&gt;32bit      4+4</span></span><br><span class="line"><span class="comment">1byte=8bit         1  对齐到 4</span></span><br><span class="line"><span class="comment">4+4+4+4=16</span></span><br><span class="line"><span class="comment">***************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span>&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> a : <span class="number">19</span>;</span><br><span class="line">    <span class="type">unsigned</span> b : <span class="number">11</span>;</span><br><span class="line">    <span class="type">unsigned</span> c : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> d : <span class="number">29</span>;</span><br><span class="line">    <span class="type">char</span> index;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(struct A)=&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">struct</span> A)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(struct B)=&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">struct</span> B)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(struct C)=&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">struct</span> C)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(struct D)=&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">struct</span> D)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(struct E)=&quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">struct</span> E)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//unsigned影响的只是最高位的意义，数据长度不会改变，所以sizeof（unsigned int）=4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> A)=<span class="number">3</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> B)=<span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> C)=<span class="number">12</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> D)=<span class="number">8</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">struct</span> E)=<span class="number">16</span></span><br></pre></td></tr></table></figure><h3 id="26-1、共用体对齐规则"><a href="#26-1、共用体对齐规则" class="headerlink" title="26.1、共用体对齐规则"></a><strong>26.1、共用体对齐规则</strong></h3><blockquote><p>union的存储空间先看它的成员中哪个占的空间最大,拿他与其他成员的元长度比较,如果可以整除</p><p>一般而言,共用体类型实际占用存储空间为其最长的成员所占的存储空间；</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">m1</span>&#123;</span>  </span><br><span class="line">    <span class="type">char</span>   a;   <span class="comment">// 长度1  </span></span><br><span class="line">    <span class="type">int</span>   b[<span class="number">5</span>]; <span class="comment">// 长度4*5  </span></span><br><span class="line">    <span class="type">double</span>   c; <span class="comment">// 长度8  </span></span><br><span class="line">    <span class="type">int</span>   d[<span class="number">3</span>]; <span class="comment">// 3*4 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">m2</span>&#123;</span>  </span><br><span class="line">    <span class="type">char</span>   a;    <span class="comment">// 长度1  </span></span><br><span class="line">    <span class="type">int</span>   b[<span class="number">5</span>]; <span class="comment">// 长度4*5  </span></span><br><span class="line">    <span class="type">int</span>   d[<span class="number">3</span>]; <span class="comment">// 3*4 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">m3</span>&#123;</span>  </span><br><span class="line">    <span class="type">char</span>   a;   <span class="comment">// 长度1  </span></span><br><span class="line">    <span class="type">double</span>   c; <span class="comment">// 长度8  </span></span><br><span class="line">    <span class="type">int</span>   d[<span class="number">3</span>]; <span class="comment">// 3*4 </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof m1 = &quot;</span> &lt;&lt;<span class="keyword">sizeof</span>(m1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof m2 = &quot;</span> &lt;&lt;<span class="keyword">sizeof</span>(m2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof m3 = &quot;</span> &lt;&lt;<span class="keyword">sizeof</span>(m3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果:</span></span><br><span class="line"><span class="keyword">sizeof</span> m1 = <span class="number">24</span></span><br><span class="line"><span class="keyword">sizeof</span> m2 = <span class="number">20</span></span><br><span class="line"><span class="keyword">sizeof</span> m3 = <span class="number">16</span></span><br></pre></td></tr></table></figure><h3 id="27、啥叫宏函数以及作⽤"><a href="#27、啥叫宏函数以及作⽤" class="headerlink" title="27、啥叫宏函数以及作⽤"></a><strong>27、啥叫宏函数以及作⽤</strong></h3><blockquote><p>在项⽬中，经常把⼀些短⼩⽽⼜频繁使⽤的函数写成宏函数，这是由于宏函数没有普通函数参数压栈、跳转、返回等的开销，可以调⾼程序的效率。 宏通过使⽤参数，可以创建外形和作⽤都与函数类似地类 函数宏(function-like macro). 宏的参数也⽤圆括号括起来，来保证宏函数的完整性。</p></blockquote><h3 id="28、如何理解库函数"><a href="#28、如何理解库函数" class="headerlink" title="28、如何理解库函数"></a><strong>28、如何理解库函数</strong></h3><blockquote><p>库是已经写好的、成熟的、可复⽤的代码。每个程序都需要依赖很多底层库，不可能每个⼈的代码从零开始编写代码，因此库的存在具有⾮常重要的意义。 在我们的开发的应⽤中经常有⼀些公共代码是需要反复使⽤的，就把这些代码编译为库⽂件。 库可以简单看成⼀组⽬标⽂件的集合，将这些⽬标⽂件经过压缩打包之后形成的⼀个⽂件。像在Windows这样的平台上，最常⽤的c语⾔库是由集成按开发环境所附带的运⾏库，这些库⼀般由编译⼚商提供</p></blockquote><h3 id="29、连接符"><a href="#29、连接符" class="headerlink" title="29、连接符"></a><strong>29、连接符</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V(x)  var##x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> var1=<span class="number">123</span>,var2=<span class="number">222</span>,var3=<span class="number">321</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">V</span>(<span class="number">1</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">V</span>(<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">V</span>(<span class="number">3</span>)&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">222</span></span><br><span class="line"><span class="number">321</span></span><br><span class="line"><span class="comment">//预处理的替换，只会做最简单的浅层替换，而不会去考虑这个字符串是从哪里来的</span></span><br></pre></td></tr></table></figure><h3 id="30、变量"><a href="#30、变量" class="headerlink" title="30、变量"></a><strong>30、变量</strong></h3><blockquote><p>静态全局变量</p><blockquote><p>在函数外定义的静态变量——静态全局变量，该变量的作用域只能在定义该变量的文件中，不能被其他文件通过<em>extern</em>引用。</p></blockquote><p>全局变量</p><blockquote><p>全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同，区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。</p></blockquote></blockquote><h3 id="31、内存分区"><a href="#31、内存分区" class="headerlink" title="31、内存分区"></a><strong>31、内存分区</strong></h3><p>​<strong>31.1 程序运行前 – Data段和BSS段</strong></p><blockquote><p>DATA 段（全局初始化区）存放初始化的全局变量和静态变量；BSS 段（全局未初始化区）存放未初始化的全局变量和静态变量。</p></blockquote><p>​<strong>31.2 程序运行后 – 内存四区</strong></p><blockquote><p>&lt;– 栈区 –&gt; (临时区,当函数执行完毕的时候,自动释放)<br>由编译器自动分配释放, 存放函数的参数值,局部变量，局部常量等. </p><p>&lt;– 堆区 !–&gt;（需要及时释放,可能会内存泄漏）<br>一般由程序员分配释放(动态内存申请与释放),若程序员不释放,程序结束时可能由操作系统回收</p><p>&lt;– 全局区 !–&gt; (静态区)<br>全局变量和静态变量存放在此. 里面细分有一个常量区,  该区域是在程序结束后由操作系统释放.</p><p>&lt;– 常量区 !–&gt;<br>字符串常量和全局常量存放在此，局部常量存放再栈区.</p><p>&lt;– 代码区 !–&gt;）(主要是指函数，不由我们关心，是交给操作系统托管的)<br>这个区域存放函数体的二进制代码.是由操作系统进行管理的·</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> b; <span class="comment">//栈区</span></span><br><span class="line">    <span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>;<span class="comment">//栈区</span></span><br><span class="line">    <span class="type">char</span> *p2;<span class="comment">//栈区</span></span><br><span class="line">    ---------------------</span><br><span class="line">    <span class="type">char</span> *p3 = <span class="string">&quot;123456&quot;</span>;<span class="comment">//p3在栈区，123456/0在文字常量区（全局区）</span></span><br><span class="line">    ---------------------</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>;<span class="comment">//静态初始化区（全局区）</span></span><br><span class="line">    p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);<span class="comment">//分配得来的10和20字节得区域就在堆区。</span></span><br><span class="line">    <span class="built_in">strcpy</span>(p1,<span class="string">&quot;123456&quot;</span>);<span class="comment">// 123456/0放在常量区，编译器可能会将它与p3所指向得&quot;123456&quot;优化成一个地方。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="32、static"><a href="#32、static" class="headerlink" title="32、static"></a>32、<strong>static</strong></h3><blockquote><p>(1）在修饰变量的时候，static 修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。</p><p>作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；</p><p>(2）static 修饰全局变量的时候，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 extern 外部声明也不可以。</p><p>(3）static 修饰一个函数，则这个函数的只能在本文件中调用，不能被其他文件调用。</p><p>static 修饰的变量存放在全局数据区的静态变量区，包括全局静态变量和局部静态变量，都在全局数据区分配内存。初始化的时候自动初始化为 0。</p><p><strong>静态资源是类初始化的时候加载的，而非静态资源是类实例化对象的时候加载的。</strong></p></blockquote><p><strong>静态数据成员</strong></p><blockquote><p>（1）静态数据成员可以实现多个对象之间的数据共享，它是类的所有对象的共享成员，它在内存中只占一份空间，如果改变它的值，则各对象中这个数据成员的值都被改变。</p><p>（2）静态数据成员是在程序开始运行时被分配空间，到程序结束之后才释放，只要类中指定了静态数据成员，即使不定义对象，也会为静态数据成员分配空间。</p><p>（3）静态数据成员可以被初始化，但是只能在类体外进行初始化，若未对静态数据成员赋初值，则编译器会自动为其初始化为 0。</p><p>（4）静态数据成员既可以通过对象名引用，也可以通过类名引用。</p></blockquote><p><strong>静态成员函数</strong></p><blockquote><p>（1）静态成员函数和静态数据成员一样，他们都属于类的静态成员，而不是对象成员。</p><p>（2）非静态成员函数有 this 指针，而静态成员函数<strong>没有 this 指针</strong>。</p><p>（3）静态成员函数主要用来<strong>访问静态数据成员</strong>而不能访问非静态成员。</p></blockquote><h3 id="33、请写出-float-x-与“零值”比较的-if-语句"><a href="#33、请写出-float-x-与“零值”比较的-if-语句" class="headerlink" title="33、请写出 float x 与“零值”比较的 if 语句"></a>33、<strong>请写出 float x 与“零值”比较的 if 语句</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> EPSINON = <span class="number">0.00001</span>;</span><br><span class="line"><span class="keyword">if</span> ((x &gt;= - EPSINON) &amp;&amp; (x &lt;= EPSINON)</span><br><span class="line">    不可将浮点变量用“==”或“！=”与数字比较，应该设法转化成“&gt;=”或“&lt;=”此类形式。 </span><br></pre></td></tr></table></figure><h3 id="34、BOOL-flag-与“零值”比较的-if-语句"><a href="#34、BOOL-flag-与“零值”比较的-if-语句" class="headerlink" title="34、BOOL flag 与“零值”比较的 if 语句"></a>34、<strong>BOOL flag 与“零值”比较的 if 语句</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag)</span><br><span class="line"><span class="keyword">if</span> (!flag)</span><br></pre></td></tr></table></figure><h3 id="35、代码区"><a href="#35、代码区" class="headerlink" title="35、代码区"></a>35、<strong>代码区</strong></h3><blockquote><p>代码区的内存是由系统控制的</p></blockquote><blockquote><p>代码区的存放 :程序中的函数编译后cpu指令</p><p>代码区的地址:函数的地址,程序的入口地址，程序的名字函数的名称也是一个指针，可以通过查询函数名称所处的内存地址，查询函数存放的区域。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main:0x%p\n&quot;</span>,main);<span class="comment">//打印main函数的存放地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="36、傻逼指针"><a href="#36、傻逼指针" class="headerlink" title="36、傻逼指针"></a>36、<strong>傻逼指针</strong></h3><blockquote><p>用变量a 给出下面的定义</p><ol><li>一个有10个指针的数组，该指针是指向一个整型数的;</li><li>一个指向有10个整型数数组的指针;</li><li>一个指向函数的指针，该函数有一个整型参数并返回一个整型数;</li><li>一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数;</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>)<span class="type">int</span> * a[<span class="number">10</span>];    <span class="number">2</span>)<span class="type">int</span> (*a)[<span class="number">10</span>] <span class="number">3</span>)<span class="type">int</span> (*a)(<span class="type">int</span>);  <span class="number">4</span>) <span class="type">int</span> (*a[<span class="number">10</span>])(<span class="type">int</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a; <span class="comment">//一个整型数</span></span><br><span class="line"><span class="type">int</span> *a; <span class="comment">//一个指向整型数的指针</span></span><br><span class="line"><span class="type">int</span> **a;<span class="comment">//一个指向指针的指针，它指向的指针是指向一个整型数</span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];<span class="comment">//一个有10个整型数的数组</span></span><br><span class="line"><span class="type">int</span> *a[<span class="number">10</span>]; <span class="comment">//一个有10个指针的数组，该指针是指向一个整型数的</span></span><br><span class="line"><span class="type">int</span> (*a)[<span class="number">10</span>];<span class="comment">//一个指向有10个整型数数组的指针</span></span><br><span class="line"><span class="type">int</span> (*a)(<span class="type">int</span>); <span class="comment">//一个指向函数的指针，该函数有一个整型参数并返回一个整型数</span></span><br><span class="line"><span class="type">int</span> (*a[<span class="number">10</span>])(<span class="type">int</span>); <span class="comment">//一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数</span></span><br></pre></td></tr></table></figure><h3 id="37、动态链接库和静态链接库的区别"><a href="#37、动态链接库和静态链接库的区别" class="headerlink" title="37、动态链接库和静态链接库的区别"></a>37、<strong>动态链接库和静态链接库的区别</strong></h3><blockquote><p>静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，无论愿不愿意，lib指令都全部被直接包含在最终生成的EXE文件中了。但是若使用DLL， 该DLL不必被包含在最终的EXE文件中，EXE文件执行时可以动态的引用和卸载这个EXE独立的DLL文件。</p><p>静态链接库和动态链接库的另外的一个区别在于静态链接库中不能再包含其他的动态链接库和静态链接库，而动态链接库中可以在包含其它的动态或静态链接库。动态库就是在需要调用其中的函数时，根据函数映射表中找到该函数然后调用堆栈中执行。</p><p>如果当前工程中有多处对dll文件中同一个函数调用，那么执行时，这个函数只会留下一份拷贝。但是如果有多处对lib文件中同一个函数的调用，那么执行时，该函数在当前程序的执行空间里留下多份拷贝，而且是一处调用就产生一份拷贝。</p></blockquote><h3 id="38、C-中有malloc-free，为什么还有new-delete"><a href="#38、C-中有malloc-free，为什么还有new-delete" class="headerlink" title="38、C++中有malloc&#x2F;free，为什么还有new&#x2F;delete"></a>38、<strong>C++中有malloc&#x2F;free，为什么还有new&#x2F;delete</strong></h3><blockquote><p>1）malloc&#x2F;free是C&#x2F;C++标准库函数，new&#x2F;delete是C++运算符。他们都可以用于动态申请和释放内存。</p><ol start="2"><li><p>对于内置类型数据而言，二者没有多大区别。malloc申请内存的时候要制定分配内存的字节数，而且不会做初始化；new申请的时候有默认的初始化，同时可以指定初始化</p></li><li><p>对于类类型的对象而言，用malloc&#x2F;free无法满足要求的。对象在创建的时候要自动执行构造函数，消亡之前要调用析构函数。由于malloc&#x2F;free是库函数而不是运算符，不在编译器控制之内，不能把执行构造函数和析构函数的任务强加给它，因此，C++还需要new&#x2F;delete。</p></li></ol><p>4）内部数据类型是编译器本身就认识的，不需要用户自己定义。如：基本数据类型：int，char，double等都是内部数据类型；2：非内部数据类型不是编译器本身就认识的，需要用户自己定义才能让编译器识别。如：由class，struct，union等关键字修饰 的变量都是非内部数据类型。</p></blockquote><h3 id="39、有符号和无符号混合三目运算问题"><a href="#39、有符号和无符号混合三目运算问题" class="headerlink" title="39、有符号和无符号混合三目运算问题"></a>39、<strong>有符号和无符号混合三目运算问题</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">-20</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    (a+b &gt; <span class="number">6</span>) ? (c=<span class="number">1</span>) : (c=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//c=1</span></span><br><span class="line"><span class="comment">//当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此-20变成了一个非常大的正整数，所以该表达式计算出的结果c=1。</span></span><br></pre></td></tr></table></figure><h3 id="40、malloc和calloc的区别"><a href="#40、malloc和calloc的区别" class="headerlink" title="40、malloc和calloc的区别"></a>40、<strong>malloc和calloc的区别</strong></h3><blockquote><p>malloc返回的内存是没有被初始化的，所以可能包含着任何的随机垃圾，应该在其后马上调用memset函数进行初始化为0的操作；</p></blockquote><blockquote><p>函数malloc()和函数calloc()的主要区别是前者不能初始化所分配的内存空间,而后者能。如果由malloc()函数分配的内存空间原来没有被使用过，则其中的每一位可能都是0;反之,如果这部分内存曾经被分配过,则其中可能遗留有各种各样的数据。也就是说，使用malloc()函数的程序开始时(内存空间还没有被重新分配)能正常进行,但经过一段时间(内存空间还已经被重新分配)可能会出现问题。</p></blockquote><blockquote><p>函数calloc()会将所分配的内存空间中的每一位都初始化为零,也就是说,如果你是为字符类型或整数类型的元素分配内存,那麽这些元素将保证会被初始化为0;如果你是为指针类型的元素分配内存,那麽这些元素通常会被初始化为空指针;如果你为实型数据分配内存,则这些元素会被初始化为浮点型的零。但是效率低下，很多情况的空间申请是不需要初始值的。</p></blockquote><p>**realloc(void *__ptr, size_t __size)**：更改已经配置的内存空间，即更改由malloc()函数分配的内存空间的大小。</p><blockquote><p>如果将分配的内存减少，realloc仅仅是改变索引的信息。</p></blockquote><blockquote><p>如果是将分配的内存扩大，则有以下情况：<br>1）如果当前内存段后面有需要的内存空间，则直接扩展这段内存空间，realloc()将返回原指针。<br>2）如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并(free)原来的数据块释放掉，返回新的内存块位置。<br>3）如果申请失败，将返回NULL，此时，原来的指针仍然有效。</p></blockquote><p><strong>malloc(zise_t size);</strong></p><blockquote><p>malloc是对没有分配过内存块的直接进行分配，返回值是分配好内存块的返回值是分配好内存块的头指针。通过malloc分配好的内存块一般要用free(size_t size)来释放内存块</p></blockquote><p>*<em>void <em>calloc(size_t numElements,size_t sizeOfElement);</em></em></p><blockquote><p>calloc()函数有两个参数,分别为元素的数目和每个元素的大小,这两个参数的乘积就是要分配的内存空间的大小。</p></blockquote><p>*<em>void <em>alloca(size_t );</em></em></p><blockquote><p>在栈上申请内存，用完会在退出栈时自动释放，无需手动释放。</p></blockquote><h3 id="41、函数重写、重载、重定义"><a href="#41、函数重写、重载、重定义" class="headerlink" title="41、函数重写、重载、重定义"></a>41、函数重写、重载、重定义</h3><p><strong>函数重载</strong></p><blockquote><p>必须在同一个类中进行</p><p>子类无法重载父类的函数，父类同名函数将被名称覆盖（C++编译器看到名字相同，不会去父类函数中找名字相同的函数</p><p>重载是在<strong>编译期间</strong>根据参数类型和个数决定函数调用</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul></blockquote><p><strong>函数重写</strong></p><blockquote><p>必须发生于父类与子类之间</p><p>并且父类与子类中的函数必须有完全相同的原型（完全相同</p><p>使用virtual声明之后能够产生多态(如果不使用virtual，那叫重定义)</p><p>多态是在<strong>运行期间</strong>根据具体对象的类型决定函数调用</p></blockquote><h3 id="42、多态满足的三个条件："><a href="#42、多态满足的三个条件：" class="headerlink" title="42、多态满足的三个条件："></a>42、多态满足的三个条件：</h3><p>1、要有继承  2、要有虚函数重写   3、要有父类指针指向子类对象</p><h3 id="43、volatile和extern分别在哪个阶段起作用？"><a href="#43、volatile和extern分别在哪个阶段起作用？" class="headerlink" title="43、volatile和extern分别在哪个阶段起作用？"></a>43、volatile和extern分别在哪个阶段起作用？</h3><p>volatile应该是在编译阶段，extern在链接阶段。</p><h3 id="44、判断编译器的大小端"><a href="#44、判断编译器的大小端" class="headerlink" title="44、判断编译器的大小端"></a>44、判断编译器的大小端</h3><p>1.移位操作</p><p>地址： 高地址 ——————&gt; 低地址<br>小端模式存放：0000 0001 &gt;&gt; 1 &#x3D;&#x3D; 0000 0000<br>大端模式存放：1000 0000 &gt;&gt; 1 &#x3D;&#x3D; 0100 0000</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TRUE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FALSE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> check_big_endian(n)n&gt;&gt;1?TRUE:FALSE</span></span><br></pre></td></tr></table></figure><p>2.联合体</p><p>union成员共享同一块大小的内存，一次只能使用其中的一个成员，对某一个成员赋值，会覆盖其他成员的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">check_little_endian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="type">int</span>  b;</span><br><span class="line"></span><br><span class="line">&#125;u;</span><br><span class="line"></span><br><span class="line">u.b = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="type">bool</span>)(u.a == <span class="number">0x78</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、通过强制类型转换判断</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">check_little_endian</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *p = (<span class="type">char</span> *)&amp;i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (*p == <span class="number">0x78</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="45、volatile"><a href="#45、volatile" class="headerlink" title="45、volatile"></a>45、volatile</h3><p>防止编译器的优化，<strong>告诉编译器，与该变量有关的运算，不要进行编译优化</strong>，每次对变量内容的引用会重新<strong>从内存中加载</strong>而不是从变量在寄存器里面的拷贝加载。</p><p>volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a = i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//其他代码，并未明确告诉编译器，对i进行过操作</span></span><br><span class="line"><span class="type">int</span> b = i;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">volatile 指出 i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在b中。而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问。</span></span><br></pre></td></tr></table></figure><h3 id="47、inline"><a href="#47、inline" class="headerlink" title="47、inline"></a>47、inline</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//则调用： cout&lt;&lt;max(a, b)&lt;&lt;endl; 没有函数压栈的开销，内联函数提升程序运行的效率。</span></span><br><span class="line"><span class="comment">//在编译时展开为： cout&lt;&lt;(a &gt; b ? a : b)&lt;&lt;endl;</span></span><br></pre></td></tr></table></figure><p>内联函数必须是和函数体声明在一起才有效</p><p>在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有关键字inline</p><p>inline是一种以空间换时间的做法，省去调用函数的开销。使用内联函数可以节省运行时间，但却增加了目标程序的长度。所以代码很长或者有循环、递归的函数不适宜使用内联函数，就算用了编译器也会放弃内联方式，而采用像调用普通函数的方式去调用它。只有那些那些规模较小而又被频繁调用的简单函数，才适合定义为inline函数。</p><h3 id="48、说说内联函数和宏函数的区别"><a href="#48、说说内联函数和宏函数的区别" class="headerlink" title="48、说说内联函数和宏函数的区别"></a>48、说说内联函数和宏函数的区别</h3><ol><li>宏定义不是函数，但是使用起来像函数。预处理器用复制宏代码的方式代替函数的调用，省去了函数压栈退栈过程，提高了效率；而内联函数本质上是一个函数，内联函数一般用于函数体的代码比较简单的函数，不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。</li><li>宏函数是在预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 ；而内联函数则是在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开，这样可以省去函数的调用的开销，提高效率</li><li>宏定义是没有类型检查的，无论对还是错都是直接替换；而内联函数在编译的时候会进行类型的检查，内联函数满足函数的性质，比如有返回值、参数列表等</li></ol><h3 id="49、sizeof"><a href="#49、sizeof" class="headerlink" title="49、sizeof"></a>49、sizeof</h3><p><strong>1.如果是数组</strong>*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(“<span class="keyword">sizeof</span>数组名=%d\n”,<span class="keyword">sizeof</span>(a));</span><br><span class="line"><span class="built_in">printf</span>(“<span class="keyword">sizeof</span> *数组名=%d\n”,<span class="keyword">sizeof</span>(*a));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行结果</span></span><br><span class="line"><span class="comment">//sizeof数组名=20</span></span><br><span class="line"><span class="comment">//sizeof *数组名=4</span></span><br></pre></td></tr></table></figure><p><strong>2.如果是指针，sizeof只会检测到是指针的类型，指针都是占用4个字节的空间（32位机）。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = “sadasdasd”;</span><br><span class="line"><span class="keyword">sizeof</span>( p):<span class="number">4</span></span><br><span class="line"><span class="keyword">sizeof</span>(*p):<span class="number">1</span><span class="comment">//指向一个char类型的</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test13</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str1 = <span class="string">&quot;ancd\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str2[<span class="number">10</span>] = <span class="string">&quot;abcd\n&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str3[][<span class="number">10</span>] = &#123;<span class="string">&quot;abcd\n&quot;</span>,<span class="string">&quot;&quot;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str4[] = &#123;<span class="string">&quot;abcd\n&quot;</span>,<span class="string">&quot;efgh\n&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(str1) = &quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(str1)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(str2) = &quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(str2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(str3) = &quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(str3)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;sizeof(str4) = &quot;</span>&lt;&lt;<span class="keyword">sizeof</span>(str4)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*(64bit)</span></span><br><span class="line"><span class="comment">sizeof(str1) = 8</span></span><br><span class="line"><span class="comment">sizeof(str2) = 10</span></span><br><span class="line"><span class="comment">sizeof(str3) = 20</span></span><br><span class="line"><span class="comment">sizeof(str4) = 16</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>49.1 sizeof和strlen</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">char</span> str[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//4</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;hello&quot;</span>;    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//5 </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(str) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//6</span></span><br><span class="line">    fun(str); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">10</span>] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(str); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><h3 id="50、C-空指针访问成员函数"><a href="#50、C-空指针访问成员函数" class="headerlink" title="50、C++空指针访问成员函数"></a>50、C++空指针访问成员函数</h3><blockquote><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShowPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mAge &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person * p = <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;<span class="built_in">ShowClassName</span>(); <span class="comment">//空指针，可以调用成员函数</span></span><br><span class="line">    <span class="comment">//但是如果成员函数中用到了this指针，就不可以了</span></span><br><span class="line"><span class="comment">//p-&gt;ShowPerson();  //出错，因为访问了mAge成员变量，相当于this-&gt;mAge </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="51、sizeof-类-的大小"><a href="#51、sizeof-类-的大小" class="headerlink" title="51、sizeof(类)的大小"></a>51、sizeof(类)的大小</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> mA;<span class="comment">//非静态成员变量占对象空间</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mB; <span class="comment">//静态成员变量不占对象空间</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//函数也不占对象空间，所有函数共享一个函数实例</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sfunc</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">//静态成员函数也不占对象空间</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NULL_Class</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(Person) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(NULL_Class) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  sizeof(Person)  = 4 (int mA) 只有非静态成员变量才属于类的对象上</span></span><br><span class="line"><span class="comment">//  sizeof(NULL_Class) = 1  空对象占一个字节</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">aa</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> <span class="keyword">virtual</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> b[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> a[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bb</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>:<span class="keyword">public</span> <span class="keyword">virtual</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> b[<span class="number">2</span>];</span><br><span class="line">    <span class="type">char</span> c[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">cc</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">bb</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sizeof</span>(A)&lt;&lt;endl&lt;&lt;<span class="built_in">sizeof</span>(B)&lt;&lt;endl&lt;&lt;<span class="built_in">sizeof</span>(C);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//虚函数会产生一个指向虚函数表的指针，64位，指针占8个字节</span></span><br><span class="line"><span class="comment">//sizeof(A) = 2*1 + 8 = 10</span></span><br><span class="line"><span class="comment">//sizeof(B) = 2*1 + 2*1 + 8 = 12 补齐到16 +sizeof(A) = 32</span></span><br><span class="line"><span class="comment">//sizeof(C) = 2*1 + 2*1 + 2*1 + 8 = 14 补齐到16 +sizeof(B) = 48;</span></span><br></pre></td></tr></table></figure><h3 id="52、mem系列函数"><a href="#52、mem系列函数" class="headerlink" title="52、mem系列函数"></a>52、mem系列函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">memcpy</span> <span class="params">(<span class="type">void</span> * destination, <span class="type">const</span> <span class="type">void</span> * source, <span class="type">size_t</span> num )</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="built_in">memcpy</span>(a + <span class="number">3</span>, a, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出 0 1 2 0 1 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">因为memcpy的最后一个参数是需要拷贝的字节的数目！一个int类型占据4个字节！这样的话，本题5字节，实际上只能移动2个数字（往大的去）。如果要想达到将a地址开始的5个元素拷贝到a+3地址处，需要这么写：memcpy(a + 3, a, 5*sizeof(int));</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span>*s ,<span class="type">int</span> ch,<span class="type">size_t</span> n)</span>;  <span class="comment">//将内存地址s处的n个字节的每个字节都替换为ch，并返回s。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*buf1, <span class="type">const</span> <span class="type">void</span> *buf2, <span class="type">size_t</span> n)</span>; <span class="comment">//比较内存区域buf1和buf2的前n个字节</span></span><br><span class="line"><span class="comment">//当buf1&lt;buf2时，返回值小于0</span></span><br><span class="line"><span class="comment">//当buf1==buf2时，返回值=0</span></span><br><span class="line"><span class="comment">//当buf1&gt;buf2时，返回值大于0</span></span><br></pre></td></tr></table></figure><h3 id="53、printf从右向左编译"><a href="#53、printf从右向左编译" class="headerlink" title="53、printf从右向左编译"></a>53、printf从右向左编译</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test01</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> *p = arr;</span><br><span class="line">    *(p++)+=<span class="number">89</span>;<span class="comment">//=&gt; *p+=89; p++ =&gt; arr[0]+=89=90; p指向arr[1]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,%d\n&quot;</span>,*p,*(++p));</span><br><span class="line">    <span class="comment">//printf是从左向右打印，从右向左编译 先执行（++p） p指向了arr[2];</span></span><br><span class="line">    <span class="comment">//所以结果都为3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3,3</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,a--,a,a++);</span><br><span class="line"><span class="comment">//1.a++ =&gt; a=2</span></span><br><span class="line"><span class="comment">//2.a不变 a=2</span></span><br><span class="line"><span class="comment">//3.a-- =&gt;先执行打印a，再执行a--; a=1;</span></span><br><span class="line"><span class="comment">//4.打印a 和 a++</span></span><br><span class="line"><span class="comment">//结果：2,1,1</span></span><br></pre></td></tr></table></figure><h3 id="54、类初始化列表执行顺序"><a href="#54、类初始化列表执行顺序" class="headerlink" title="54、类初始化列表执行顺序"></a>54、类初始化列表执行顺序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">base</span>(<span class="type">int</span> i): <span class="built_in">b</span>(i++),<span class="built_in">c</span>(i++),<span class="built_in">a</span>(i++)&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">base <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">p.a = <span class="number">10</span>;</span><br><span class="line">p.b = <span class="number">11</span>;</span><br><span class="line">p.c = <span class="number">12</span>;</span><br><span class="line"><span class="comment">//类中变量赋值顺序是变量声明的顺序 先a后b再c</span></span><br></pre></td></tr></table></figure><h3 id="55、多态内存布局"><a href="#55、多态内存布局" class="headerlink" title="55、多态内存布局"></a>55、多态内存布局</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;animal is speaking&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat is speaking&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cl /d1 reportSingleClassLayoutAnimal <span class="string">&quot;多态的基本语法.cpp&quot;</span></span><br></pre></td></tr></table></figure><p>多态父类内部是由一个虚函数表指针，指向虚函数表，表内存放函数入口地址</p><p><img src="H:\interview\interview_pic\多态基类的内部.png" alt="多态派生类没有重写父类"></p><p>子类重写父类虚函数时，虚函数表内为自己作用域下的函数</p><p><img src="H:\interview\interview_pic\多态派生类的内部.png" alt="多态派生类的内部"></p><p>子类不重写父类虚函数时，虚函数表内为父类作用域下的函数</p><p><img src="H:\interview\interview_pic\多态派生类没有重写父类.png" alt="多态基类的内部"></p><h3 id="56、c-中四种cast转换"><a href="#56、c-中四种cast转换" class="headerlink" title="56、c++中四种cast转换"></a>56、c++中四种cast转换</h3><p><strong>1、const_cast</strong></p><blockquote><p>用于将const变量转为非const</p><p>const_cast只能转换<strong>指针或引用</strong> 不能转换变量</p></blockquote><p><strong>2、static_cast</strong></p><blockquote><p>static_cast 可以实现 C++内置基本类型的转换、也可以实现<strong>具有继承关系类型之</strong>间的转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d = <span class="number">12.34</span>;</span><br><span class="line"><span class="type">int</span> a = static_cast&lt;<span class="type">int</span>&gt;(d); <span class="comment">// a = 12</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *cptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="type">int</span> *ptr1 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span> *&gt;(cptr);c <span class="comment">//出错，const为常量不能转化</span></span><br><span class="line"><span class="type">int</span> *ptr2 = (<span class="type">int</span>*)cptr;<span class="comment">//c强制转换不会出错，不会做安全检查</span></span><br></pre></td></tr></table></figure><p>用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；</p><p>static_cast 是在<strong>编译</strong>的时候进行转换的</p></blockquote><p><strong>3、dynamic_cast</strong></p><blockquote><p>用于动态类型转换。<strong>只能在继承类对象的指针或引用之间进行转换</strong>，只能用于<strong>含有虚函数</strong>的类，用于类层次间的<strong>向上和向下</strong>转化。只能转指针或引用。向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。</p></blockquote><blockquote><p>向上转换：指的是子类向基类的转换</p></blockquote><blockquote><p>向下转换：指的是基类向子类的转换</p></blockquote><blockquote><p>它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。</p><p>dynamic_cast是在<strong>运行</strong>的时候进行转换的</p></blockquote><p><strong>4、reinterpret_cast</strong></p><blockquote><p>reinterpret_cast用在<strong>任意指针（或引用）</strong>类型之间的转换；以及<strong>指针与足够大的整数类型</strong>之间的转换；从<strong>整数类型（包括枚举类型）到指针类型</strong>，</p></blockquote><p><strong>5、为什么不使用C的强制转换？</strong></p><blockquote><p>C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。</p></blockquote><h3 id="57、new和malloc的区别"><a href="#57、new和malloc的区别" class="headerlink" title="57、new和malloc的区别"></a>57、new和malloc的区别</h3><p><strong>属性</strong><br>    new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。</p><p><strong>参数</strong><br>    使用new操作符申请内存分配时<strong>无须指定内存块的大小</strong>，编译器会根据类型信息自行计算。<br>    而malloc则需要显式地指出所需内存的尺寸。</p><p><strong>返回类型</strong><br>    new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p><p><strong>自定义类型</strong><br>    new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。                delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>/<span class="built_in">free</span>是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</span><br></pre></td></tr></table></figure><p> <strong>重载</strong><br>    C++允许自定义operator new 和 operator delete 函数控制动态内存的分配。</p><p><strong>内存区域</strong><br>    new做两件事：分配内存和<strong>调用类的构造函数</strong>，delete是：<strong>调用类的析构函数</strong>和释放内存。而malloc和free只是分配和释放内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new操作符从自由存储区（<span class="built_in">free</span> store）上为对象动态分配内存空间，而<span class="built_in">malloc</span>函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用<span class="built_in">malloc</span>从堆上分配内存，使用<span class="built_in">free</span>释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</span><br></pre></td></tr></table></figure><p><strong>分配失败</strong><br>    new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p><p><strong>内存泄漏</strong><br>    内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc确不可以。</p><h3 id="58、1G内存的计算机malloc-1-2G"><a href="#58、1G内存的计算机malloc-1-2G" class="headerlink" title="58、1G内存的计算机malloc(1.2G)"></a>58、1G内存的计算机malloc(1.2G)</h3><p>malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关。程序运行时，堆空间只是程序向操作系统申请划出来的一大块虚拟地址空间。应用程序通过malloc申请空间，得到的是在虚拟地址空间中的地址，之后程序运行所提供的物理内存是由操作系统完成的。</p><h3 id="59、-指针和引用的区别"><a href="#59、-指针和引用的区别" class="headerlink" title="59、**指针和引用的区别 **"></a>59、**指针和引用的区别 **</h3><p>1.指针是一个实体，而引用只是一个别名；<br>2.使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；<br>3.指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；<br>4.作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；<br>5.可以有const指针，但是没有const引用；<br>6.指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；<br>7.指针可以有多级指针（**p），而引用至于一级；<br>8.指针和引用使用++运算符的意义不一样；<br>9.如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。</p><p><strong>引用的本质在c++内部实现是一个指针常量.</strong></p><h3 id="60、函数压栈顺序"><a href="#60、函数压栈顺序" class="headerlink" title="60、函数压栈顺序"></a>60、函数压栈顺序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test06</span><span class="params">(<span class="type">int</span> _a,<span class="type">int</span> _b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;_a的内存地址&quot;</span>&lt;&lt;&amp;_a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;_b的内存地址&quot;</span>&lt;&lt;&amp;_b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;a的内存地址&quot;</span>&lt;&lt;&amp;a&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;b的内存地址&quot;</span>&lt;&lt;&amp;b&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;c的内存地址&quot;</span>&lt;&lt;&amp;c&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">_a的内存地址0x61fe00</span></span><br><span class="line"><span class="comment">_b的内存地址0x61fe08</span></span><br><span class="line"><span class="comment">a的内存地址0x61fdec</span></span><br><span class="line"><span class="comment">b的内存地址0x61fde8</span></span><br><span class="line"><span class="comment">c的内存地址0x61fde0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//栈的空间内存是从高到低的</span></span><br><span class="line"><span class="comment">//故先压栈的参数地址为高地址</span></span><br><span class="line"><span class="comment">//所以压栈顺序为  _b _a a b c </span></span><br><span class="line"><span class="comment">//形参顺序从右到左 局部变量顺序从上到下</span></span><br></pre></td></tr></table></figure><h3 id="61、strcpy-和-memcpy区别"><a href="#61、strcpy-和-memcpy区别" class="headerlink" title="61、strcpy 和 memcpy区别"></a>61、strcpy 和 memcpy区别</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p>1）复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意类型(void *)的内容。strcpy只用于字符串(char *)复制，并且还会复制字符串的结束符。memcpy对于复制的内容没有限制，用途更广。<br>2）复制的方法不同。strcpy不需要指定长度，遇到结束符<strong>’\0’</strong>才会结束，所以容易溢出。memcpy则是根据第三个参数决定复制的长度<br>3）用途不同。通常在复制字符串时用strcpy，在复制其他类型数据时一般用memcpy。</p><h3 id="62、const常量与define宏定义的区别"><a href="#62、const常量与define宏定义的区别" class="headerlink" title="62、const常量与define宏定义的区别"></a>62、const常量与define宏定义的区别</h3><p>(1) 编译器处理方式不同</p><p>　　define宏是在预处理阶段展开。宏只是在编译期前做简单替换，绕过了类型检查</p><p>　　const常量是编译运行阶段使用。</p><p>(2) 类型和安全检查不同</p><p>　　define宏没有类型，不做任何类型检查，仅仅是展开。</p><p>　　const常量有具体的类型，在编译阶段会执行类型检查。</p><p>(3) 存储方式不同</p><p>　　define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。</p><p>　　const常量会在内存中分配(可以是堆中也可以是栈中。</p><p>(4)const  可以节省空间，避免不必要的内存分配。 例如： </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159 <span class="comment">//常量宏 </span></span></span><br><span class="line">      <span class="type">const</span> doulbe Pi=<span class="number">3.14159</span>; <span class="comment">//此时并未将Pi放入ROM中 ...... </span></span><br><span class="line">      <span class="type">double</span> i=Pi; <span class="comment">//此时为Pi分配内存，以后不再分配！ </span></span><br><span class="line">      <span class="type">double</span> I=PI; <span class="comment">//编译期间进行宏替换，分配内存 </span></span><br><span class="line">      <span class="type">double</span> j=Pi; <span class="comment">//没有内存分配 </span></span><br><span class="line">      <span class="type">double</span> J=PI; <span class="comment">//再进行宏替换，又一次分配内存！ </span></span><br></pre></td></tr></table></figure><p>​        const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define定义的常量在内存中有若干个拷贝。 </p><p>(5) 提高了效率。 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</p><p>(6)用define可以定义一些简单的函数（宏替换只作替换，不做计算，不做表达式求解），const是不可以定义函数的.</p><p>(7)用define定义的常量是不可以用指针变量去指向的，用const定义的常量是可以用指针去指向该常量的地址的；</p><pre><code>   宏预编译时就替换了，程序运行时，并不分配内存。</code></pre><h3 id="63、C-和C的区别"><a href="#63、C-和C的区别" class="headerlink" title="63、C++和C的区别"></a>63、C++和C的区别</h3><p>设计思想上：</p><p>C++是面向对象的语言，而C是面向过程的结构化编程语言</p><p>语法上：</p><p>C++具有封装、继承和多态三种特性</p><p>C++相比C，增加多许多类型安全的功能，比如强制类型转换</p><p>C++支持范式编程，比如模板类、函数模板等</p><h3 id="64、内存溢出-和-内存泄露"><a href="#64、内存溢出-和-内存泄露" class="headerlink" title="64、内存溢出 和 内存泄露"></a>64、内存溢出 和 内存泄露</h3><p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p><p>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_alloc</span><span class="params">(<span class="type">char</span> **p)</span></span><br><span class="line">｛</span><br><span class="line">    *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">｝</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *otr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    my_alloc(&amp;ptr);</span><br><span class="line">    <span class="built_in">strcpy</span>(ptr,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内存泄漏，分配给其他变量的内存就会减小。我们在删除一个指针之后，编译器只会释放该指针所指向的内存空间，而不会删除这个指针本身。此时p也就成为一个野指针</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">free()释放的是指针指向的内存！注意,释放的是内存，不是指针。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在,只不过现在指针指向的内容的垃圾，是未定义的，所以说是垃圾。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因此，释放内存后把指针指向NULL，防止指针在后面不小心又被解引用了。当然，具体情况要具体分析以及具体解决。比如说，你定义了一个指针，在一个函数里申请了一块内存，然后通过函数返回传递给这个指针，那么也许释放这块内存这项工作就应该留给其他函数了。*/</span></span><br></pre></td></tr></table></figure><h3 id="65、虚析构和纯虚析构"><a href="#65、虚析构和纯虚析构" class="headerlink" title="65、虚析构和纯虚析构"></a>65、虚析构和纯虚析构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Base构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Base</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Base析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> :<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Son构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Son析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Base * base = <span class="keyword">new</span> Son;</span><br><span class="line">base-&gt;<span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">delete</span> base;<span class="comment">//记得销毁</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     Base构造函数调用</span></span><br><span class="line"><span class="comment">Son构造函数调用</span></span><br><span class="line"><span class="comment">func调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Base析构函数调用</span></span><br><span class="line"><span class="comment">父类对象不会调用子类的析构函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多态使用时，父类指针在释放时无法调用到子类的析构代码，如果子类中有属性开辟到堆区，那么就会造成内存资源的泄露</p><p>解决方法：虚析构和纯虚析构</p><p><strong>虚析构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Animal的构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类虚析构</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Animal的析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>()&#123;&#125;    </span><br><span class="line">    <span class="built_in">Cat</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat的构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_name = <span class="keyword">new</span> <span class="built_in">string</span> (name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写父类纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;*m_name&lt;&lt;<span class="string">&quot;小猫在说话&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Cat的析构函数</span></span><br><span class="line">    ~<span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(m_name!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_name;</span><br><span class="line">            m_name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string *m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;TOM&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Animal的构造函数调用</span></span><br><span class="line"><span class="comment">Cat的构造函数调用</span></span><br><span class="line"><span class="comment">TOM小猫在说话</span></span><br><span class="line"><span class="comment">Cat析构函数调用</span></span><br><span class="line"><span class="comment">Animal的析构函数调用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>纯虚析构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Animal的构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//纯虚析构</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯虚析构类内声明 类外初始化</span></span><br><span class="line"><span class="comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类 不能够被实例化。</span></span><br><span class="line">Animal::~<span class="built_in">Animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Animal的纯虚析构调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cat</span>(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat的构造函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">        m_name = <span class="keyword">new</span> <span class="built_in">string</span> (name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写父类纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;*m_name&lt;&lt;<span class="string">&quot;小猫在说话&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Cat的析构函数</span></span><br><span class="line">    ~<span class="built_in">Cat</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Cat析构函数调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(m_name!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_name;</span><br><span class="line">            m_name = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string *m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal *animal = <span class="keyword">new</span> <span class="built_in">Cat</span>(<span class="string">&quot;TOM&quot;</span>);</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Animal的构造函数调用</span></span><br><span class="line"><span class="comment">Cat的构造函数调用</span></span><br><span class="line"><span class="comment">TOM小猫在说话</span></span><br><span class="line"><span class="comment">Cat析构函数调用</span></span><br><span class="line"><span class="comment">Animal的纯虚析构调用</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>纯虚析构类内声明 类外初始化<br>和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类 不能够被实例化。</p><h3 id="66、虚基类和虚继承"><a href="#66、虚基类和虚继承" class="headerlink" title="66、虚基类和虚继承"></a>66、虚基类和虚继承</h3><p><strong>菱形继承</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_age;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheep</span>: <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>: <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheeptuo</span>: <span class="keyword">public</span> sheep,<span class="keyword">public</span> Tuo&#123;&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sheeptuo st;</span><br><span class="line">    st.sheep::m_age = <span class="number">100</span>;</span><br><span class="line">    st.Tuo::m_age = <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//cout&lt;&lt;&quot;st.m_age = &quot; &lt;&lt;st.m_age&lt;&lt;endl; 报错，指定不明确</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;st.sheep::m_age = &quot;</span>&lt;&lt;st.sheep::m_age&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;st.Tuo::m_age = &quot;</span>&lt;&lt;st.Tuo::m_age&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//st.sheep::m_age = 100</span></span><br><span class="line"><span class="comment">//st.Tuo::m_age = 200  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造顺序：Animal-&gt;sheep-&gt;Tuo-&gt;Sheeptuo</span></span><br><span class="line"><span class="comment">//如果 class sheeptuo: public Tuo ,public sheep &#123;&#125;;</span></span><br><span class="line"><span class="comment">//则构造顺序：Animal-&gt;Tuo-&gt;sheep-&gt;Sheeptuo</span></span><br></pre></td></tr></table></figure><p><img src="H:\interview\interview_pic\菱形继承.png" alt="菱形继承"></p><p>sheeptuo下有两份m_age，访问时需要加作用域进程指定</p><p><strong>虚继承</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="comment">//虚基类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_age;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承前加virtual关键字后，变为虚继承</span></span><br><span class="line"><span class="comment">//此时公共的父类Animal称为虚基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheep</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tuo</span>:<span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheeptuo</span>: <span class="keyword">public</span> sheep,<span class="keyword">public</span> Tuo&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sheeptuo st;</span><br><span class="line">    st.sheep::m_age = <span class="number">100</span>;</span><br><span class="line">    st.Tuo::m_age = <span class="number">200</span>;</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;st.sheep::m_age = &quot;</span>&lt;&lt;st.sheep::m_age&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;st.Tuo::m_age = &quot;</span>&lt;&lt;st.Tuo::m_age&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;st.m_age = &quot;</span> &lt;&lt;st.m_age&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//st.sheep::m_age = 200</span></span><br><span class="line"><span class="comment">//st.Tuo::m_age = 200</span></span><br><span class="line"><span class="comment">//st.m_age = 200</span></span><br></pre></td></tr></table></figure><p><img src="H:\interview\interview_pic\虚基类和虚继承.png" alt="虚基类和虚继承"></p><h3 id="67、同名成员函数处理"><a href="#67、同名成员函数处理" class="headerlink" title="67、同名成员函数处理"></a>67、同名成员函数处理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Father</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Father - func()调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;father - func(int a)调用 &quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a=<span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> Father</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">son</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;son - func()调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    son P;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用同名非静态变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;son.p= &quot;</span> &lt;&lt; P.m_a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Father.p= &quot;</span> &lt;&lt; P.Father::m_a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用同名成员函数</span></span><br><span class="line">    P.<span class="built_in">func</span>();</span><br><span class="line">    P.Father::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// P.func(100); //报错 父类的func(int a) 函数被隐藏</span></span><br><span class="line">    P.Father::<span class="built_in">func</span>(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">son.p= 200</span></span><br><span class="line"><span class="comment">Father.p= 100</span></span><br><span class="line"><span class="comment">son - func()调用</span></span><br><span class="line"><span class="comment">Father - func()调用</span></span><br><span class="line"><span class="comment">father - func(int a)调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 子类对象可以直接访问到子类中同名成员</span><br><span class="line"><span class="number">2.</span> 子类对象加作用域可以访问到父类同名成员</span><br><span class="line"><span class="number">3.</span> 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Base::m_A = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_A;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过类名访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">通过对象访问：</span></span><br><span class="line"><span class="comment">Son  下 m_A = 200</span></span><br><span class="line"><span class="comment">Base 下 m_A = 100</span></span><br><span class="line"><span class="comment">通过类名访问：</span></span><br><span class="line"><span class="comment">Son  下 m_A = 200</span></span><br><span class="line"><span class="comment">Base 下 m_A = 100</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//同名成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过对象访问</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son s;</span><br><span class="line">s.<span class="built_in">func</span>();</span><br><span class="line">s.Base::<span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;</span><br><span class="line">Son::<span class="built_in">func</span>();</span><br><span class="line">Son::Base::<span class="built_in">func</span>();</span><br><span class="line"><span class="comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span></span><br><span class="line">Son::Base::<span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">通过对象访问： </span></span><br><span class="line"><span class="comment">Son - static void func()</span></span><br><span class="line"><span class="comment">Base - static void func()</span></span><br><span class="line"><span class="comment">通过类名访问：</span></span><br><span class="line"><span class="comment">Son - static void func()</span></span><br><span class="line"><span class="comment">Base - static void func()</span></span><br><span class="line"><span class="comment">Base - static void func(int a)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="68、构造函数和析构函数抛出异常"><a href="#68、构造函数和析构函数抛出异常" class="headerlink" title="68、构造函数和析构函数抛出异常"></a>68、构造函数和析构函数抛出异常</h3><p>一.构造函数<br>\1. 构造函数中抛出异常，会导致析构函数不能被调用，但对象本身已申请到的内存资源会被系统释放（已申请到资源的内部成员变量会被系统依次逆序调用其析构函数）。<br>\2. 因为析构函数不能被调用，所以可能会造成内存泄露或系统资源未被释放。<br>\3. 构造函数中可以抛出异常，但必须保证在构造函数抛出异常之前，把系统资源释放掉，防止内存泄露。（如何保证？？？使用auto_ptr？？？）</p><p>二.析构函数<br>\1. 不要在析构函数中抛出异常！虽然C++并不禁止析构函数抛出异常，但这样会导致程序过早结束或出现不明确的行为。<br>\2. 如果某个操作可能会抛出异常，类应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。<br>\3. 如果析构函数中异常非抛不可，那就用try catch来将异常吞下，但这样方法并不好，我们提倡有错早些报出来。</p><p><strong>最后总结</strong><br>\1. 构造函数中尽量不要抛出异常，能避免的就避免，如果必须，要考虑不要内存泄露！<br>\2. 不要在析构函数中抛出异常！</p><h3 id="69、拷贝构造函数调用时机"><a href="#69、拷贝构造函数调用时机" class="headerlink" title="69、拷贝构造函数调用时机"></a>69、拷贝构造函数调用时机</h3><ul><li><p>使用一个已经创建完毕的对象来初始化一个新对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">man</span><span class="params">(<span class="number">100</span>)</span></span>; <span class="comment">//p对象已经创建完毕</span></span><br><span class="line"><span class="function">Person <span class="title">newman</span><span class="params">(man)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">Person newman2 = man; <span class="comment">//拷贝构造</span></span><br></pre></td></tr></table></figure></li><li><p>值传递的方式给函数参数传值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相当于Person p1 = p;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="built_in">doWork</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以值方式返回局部对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">doWork2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span> *)&amp;p1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="70、构造函数和析构函数与虚函数的问题"><a href="#70、构造函数和析构函数与虚函数的问题" class="headerlink" title="70、构造函数和析构函数与虚函数的问题"></a>70、构造函数和析构函数与虚函数的问题</h3><p>1、构造函数不能声明为虚函数</p><blockquote><p>因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型，是类本身还是类的派生类等等</p></blockquote><blockquote><p>虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了。</p></blockquote><p>2、析构函数最好声明为虚函数</p><blockquote><p>首先析构函数可以为虚函数，当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。</p></blockquote><blockquote><p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。</p></blockquote><h3 id="71、vector和list"><a href="#71、vector和list" class="headerlink" title="71、vector和list"></a>71、vector和list</h3><p><strong>底层结构</strong><br>  vector的底层结构是动态顺序表，在内存中是一段连续的空间。<br>  list的底层结构是带头节点的双向循环链表，在内存中不是一段连续的空间。</p><p><strong>随机访问</strong><br>  vector支持随机访问，可以利用下标精准定位到一个元素上，访问某个元素的时间复杂度是O(1)。<br>  list不支持随机访问，要想访问list中的某个元素只能是从前向后或从后向前依次遍历，时间复杂度是O(N)。</p><p><strong>插入和删除</strong><br>  vector任意位置插入和删除的效率低，因为它每插入一个元素（尾插除外），都需要搬移数据，时间复杂度是O(N)，而且插入还有可能要增容，这样一来还要开辟新空间，拷贝元素，是旧空间，效率会更低。<br>  list任意位置插入和删除的效率高，他不需要搬移元素，只需要改变插入或删除位置的前后两个节点的指向即可，时间复杂度为O(1)。</p><p><strong>空间利用率</strong><br>  vector由于底层是动态顺序表，在内存中是一段连续的空间，所以不容易造成内存碎片，空间利用率高，缓存利用率高。<br>  list的底层节点动态开辟空间，节点容易造成内存碎片，空间利用率低，缓存利用率低。</p><p><strong>迭代器</strong><br>  vector的迭代器是原生态指针。<br>  list对原生态指针（节点的指针）进行了封装。</p><p><strong>迭代器失效</strong><br>  vector在插入元素时的时候，要重新给所有的迭代器赋值，因为插入元素有可能导致扩容，只是原来的迭代器失效，删除元素时当前迭代器同样需要重新赋值，否则会失效。<br>  list在插入元素的时候不会导致迭代器实现，删除元素的时候指挥导致当前迭代器失效，其他的迭代器不会受到影响。</p><p><strong>使用场景</strong><br>  vector适合需要高效率存储，需要随机访问，并且不管行插入和删除效率的场景。</p><h3 id="72、迭代器失效"><a href="#72、迭代器失效" class="headerlink" title="72、迭代器失效"></a>72、迭代器失效</h3><hr><p><strong>迭代器注意事项</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、迭代器不支持用&amp;操作符来初始化。</span><br><span class="line"><span class="number">2</span>、迭代器与<span class="number">0</span>进行比较会产生运行时错误。</span><br><span class="line"><span class="number">3</span>、<span class="built_in">list</span>的迭代器不支持算术运算。 </span><br><span class="line"><span class="number">4</span>、两个迭代器组成的区间是前闭后开的</span><br><span class="line"><span class="number">5</span>、迭代器指向的内容为空的时候(如已经指向end的时候)是不能访问值的，否则运行会崩溃<span class="comment">//(报错内容iterator not dereferencable)</span></span><br><span class="line">    迭代器已经指向end的时候，不能继续++了，否则运行时候会崩溃</span><br><span class="line"><span class="number">6</span>、如果迭代器所指向的元素已经被删除，那么迭代器会失效</span><br></pre></td></tr></table></figure><p><strong>哪些操作会引起迭代器失效呢？</strong></p><p><strong>vector容器</strong></p><blockquote><p>由于插入元素,或者扩容可能引起的迭代器指向的元素或者空间发生变化，从而导致迭代器失效<br>接口：insert，resize，reserve，push_back, assign</p><p>由于删除元素使得某些元素次序发生变化使得原本指向某元素的迭代器不再指向希望指向的元素。<br>接口：erase、pop_back</p><p>由于容器空间被释放导致存放原容器元素的空间不再有效，从而使得指向原空间的迭代器失效。<br>接口： clear</p><p>由于容器元素整体“迁移”导致存放原容器元素的空间不再有效，从而使得指向原空间的迭代器失效。<br>接口：swap</p></blockquote><p><strong>list</strong></p><blockquote><p>1、插入操作（insert）和接合操作（splice）不会造成原有的list迭代器失效，这在vector中是不成立的，因为vector的插入操作可能造成记忆体重新配置，导致所有的迭代器全部失效。</p><p>2、list的删除操作（erase）也只有指向被删除元素的那个迭代器失效，其他迭代器不受影响。（list目前只发现这一种失效的情况）</p></blockquote><p>**deque  **</p><blockquote><p>1、在deque容器首部或者尾部插入元素不会使得任何迭代器失效。<br>2、在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效。<br>3、在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效。</p></blockquote><p><strong>set和map</strong></p><blockquote><p>与list相同，当对它进行insert和erase操作时，操作之前的所有迭代器，在操作完成之后都依然有效，但被删除的元素的迭代器失效。</p></blockquote><h3 id="73、vector和deque"><a href="#73、vector和deque" class="headerlink" title="73、vector和deque"></a>73、vector和deque</h3><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><h3 id="74、list中的sort"><a href="#74、list中的sort" class="headerlink" title="74、list中的sort"></a>74、list中的sort</h3><p> std::list::sort 算法能做到 O(n<em>log</em>2(n)) 复杂度，而直接对 std::list 套用 std::sort 只能做到 O(<em>n</em>²)</p><h3 id="75、STL中常见容器的时间复杂度"><a href="#75、STL中常见容器的时间复杂度" class="headerlink" title="75、STL中常见容器的时间复杂度"></a>75、STL中常见容器的时间复杂度</h3><p><strong>Vector的数据模型就是数组。</strong></p><p>　优点：内存和C完全兼容、高效随机访问、节省空间</p><p>　缺点：内部插入删除元素代价巨大、动态大小查过自身容量需要申请大量内存做大量拷贝。</p><p><strong>List 的数据结构模型是链表</strong></p><p>　优点：任意位置插入删除元素常量时间复杂度、两个容器融合是常量时间复杂度</p><p>　缺点：不支持随机访问、比vector占用更多的存储空间</p><p><strong>Deque的数据模型是数组和链表的折衷：</strong></p><p>　优点：高效随机访问、内部插入删除元素效率方便、两端push pop</p><p>　缺点：内存占用比较高</p><p><strong>Map、set、multimap、multiset的数据结构模型是二叉树(红黑树)</strong></p><p>　优点：元素会按照键值排序、查找是对数时间复杂度、通过键值查元素、map提供了下标访问</p><p><strong>Map、set、multimap、multise</strong></p><p>插入: O(logN)查看:O(logN) 删除:O(logN)</p><p>**vector、deque、list **</p><p>查找：O(n)</p><p><strong>hash_map, hash_set, hash_multimap, and hash_multiset</strong></p><p>插入:O(1)，最坏情况O(N)  查看:O(1)，最坏情况O(N)  删除:O(1)，最坏情况O(N) </p><p><strong>总结</strong></p><p>1） 如果需要随机访问，用vector<br>2） 如果存储元素的数目已知，用vector<br>3） 需要任意位置随机插入删除，用list<br>4） 只有需要更多在容器的首部尾部插入删除元素，用deque<br>5） 元素是复杂结构用list，也可以用vector存储指针(需要额外的精力去维护内存)，看需求<br>6） 如果操作是基于键值，用set map<br>7） 如果需要经常的搜索，用map set<br>8） map set 的区别是map中的元素都是pair</p><h3 id="76、malloc的底层实现"><a href="#76、malloc的底层实现" class="headerlink" title="76、malloc的底层实现"></a>76、malloc的底层实现</h3><p>​Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。我们用malloc进行内存分配就是从break往上进行的。</p><p><img src="H:\interview\interview_pic\malloc时的堆区.png" alt="malloc时的堆区"></p><p>malloc函数的实质是它有一个将可用的内存块连接为一个长长的列表的所谓空闲链表。 调用malloc（）函数时，它沿着连接表寻找一个大到足以满足用户请求所需要的内存块。 然后，将该内存块一分为二（一块的大小与用户申请的大小相等，另一块的大小就是剩下来的字节）。 接下来，将分配给用户的那块内存存储区域传给用户，并将剩下的那块（如果有的话）返回到连接表上。 调用free函数时，它将用户释放的内存块连接到空闲链表上。 到最后，空闲链会被切成很多的小内存片段，如果这时用户申请一个大的内存片段， 那么空闲链表上可能没有可以满足用户要求的片段了。于是，malloc（）函数请求延时，并开始在空闲链表上检查各内存片段，对它们进行内存整理，将相邻的小空闲块合并成较大的内存块。</p><h3 id="77、一道坑题"><a href="#77、一道坑题" class="headerlink" title="77、一道坑题"></a>77、一道坑题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test07</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">memcpy</span>(&amp;data[<span class="number">2</span>], data, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;data[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//由于本题中data数组里直接放的是数字，直接强制转化为char类型，按照ASCII码进行查询，显然不会是这些数字了。也就是说，如果改成以下的定义：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// unsigned char data[MAX_DATA_SIZE] = &#123; &#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;0&#x27; &#125;;</span></span><br><span class="line"><span class="comment">// 结果就是1212345890</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a=%c\na=%d&quot;</span>,a,a);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a=</span></span><br><span class="line"><span class="comment">a=1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="78、-p-与-p；-p-与-p-的理解"><a href="#78、-p-与-p；-p-与-p-的理解" class="headerlink" title="78、*p++与*++p；(*p)++ 与 ++(*p)的理解"></a>78、<code>*p</code>++与<code>*</code>++p；(<code>*</code>p)++ 与 ++(*p)的理解</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*p++：<span class="comment">//等同于：*p;  p += 1</span></span><br><span class="line">    <span class="comment">//*p++与*(p++)是等价的   由于*和++优先级相同，且右结合</span></span><br><span class="line"></span><br><span class="line">*++p：<span class="comment">//等同于 p += 1;  *p;</span></span><br><span class="line">    </span><br><span class="line">++(*p)、++*p <span class="comment">//先把数据自增1</span></span><br></pre></td></tr></table></figure><h3 id="79、模板注意事项"><a href="#79、模板注意事项" class="headerlink" title="79、模板注意事项"></a>79、模板注意事项</h3><p><strong>普通函数与函数模板的区别</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAdd01</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">myAdd01</span>(a, c) &lt;&lt; endl; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"><span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"><span class="built_in">myAdd02</span>&lt;<span class="type">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>普通函数与函数模板的调用规则</strong></p><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line"><span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">myPrint</span>(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line">    <span class="comment">//编译器认为调用普通函数还要进行类型转换，所以调用函数模板更方便</span></span><br><span class="line"><span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> b = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">Print</span>(a, b);<span class="comment">//模板的调用</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> d = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">Print</span>(c, d);<span class="comment">//普通函数的调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;调用的普通函数&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">myPrint</span>(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; </span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;func调用&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//func函数中没有T的实现</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">test05</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// func(); 错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">func&lt;<span class="type">int</span>&gt;(); <span class="comment">//利用显示指定的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="80、char-p-和-char-p"><a href="#80、char-p-和-char-p" class="headerlink" title="80、char *p 和 char p[]"></a>80、char *p 和 char p[]</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d = <span class="number">10</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">test09</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *c1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">char</span> c2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *c3 = (<span class="type">const</span> <span class="type">char</span>* )<span class="built_in">malloc</span>(<span class="number">3</span>);</span><br><span class="line">    c3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;栈区地址&quot;</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;全局区地址&quot;</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;常量区区地址&quot;</span> &lt;&lt; &amp;d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x 0x%x %s\n&quot;</span>,&amp;c1,c1,c1); <span class="comment">//栈 常量区</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x 0x%x %s\n&quot;</span>,&amp;c2,c2,c2); <span class="comment">//栈 栈</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0x%x 0x%x %s\n&quot;</span>,&amp;c3,c3,c3); <span class="comment">//栈 常量区</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">栈区地址008FF8C4</span></span><br><span class="line"><span class="comment">全局区地址005CF338</span></span><br><span class="line"><span class="comment">常量区区地址005CCC50</span></span><br><span class="line"><span class="comment">0x8ff8b8 0x5cccdc abc</span></span><br><span class="line"><span class="comment">0x8ff8ac 0x8ff8ac abc</span></span><br><span class="line"><span class="comment">0x8ff8a0 0x5cccdc abc</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p1 = <span class="string">&quot;hello world&quot;</span>;  <span class="comment">//用来声明一个指针p，指向“hello world!”字符串起始位置。 p1在栈区 “hello world”在常量区</span></span><br><span class="line"><span class="comment">//p1指向的“hello world” 是只读的，不能改变</span></span><br><span class="line"><span class="type">char</span> p2[] = <span class="string">&quot;hello world&quot;</span>; <span class="comment">//用来声明一个数组p，数组大小为12字节。  p2在常量区  &quot;hello world&quot;在栈区</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p1)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//4</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p2)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//12</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>、A* a = new A; a-&gt;i = <span class="number">10</span>：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）A *a：<span class="comment">//a是一个局部变量，类型为指针，故而操作系统在程序栈区开辟4/8字节的空间（0x000m），分配给指针a。</span></span><br><span class="line"><span class="number">2</span>）new A：<span class="comment">//通过new动态的在堆区申请类A大小的空间（0x000n）。</span></span><br><span class="line"><span class="number">3</span>）a = new A：<span class="comment">//将指针a的内存区域填入栈中类A申请到的地址的地址。即*（0x000m）=0x000n。</span></span><br><span class="line"><span class="number">4</span>）a-&gt;i：<span class="comment">//先找到指针a的地址0x000m，通过a的值0x000n和i在类a中偏移offset，得到a-&gt;i的地址0x000n + offset，进行*(0x000n + offset) = 10的赋值操作，即内存0x000n + offset的值是10。</span></span><br></pre></td></tr></table></figure><h3 id="81、宏题目"><a href="#81、宏题目" class="headerlink" title="81、宏题目"></a>81、宏题目</h3><p>使用宏定义来获取一个结构体成员相对于该结构体首地址的偏移量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="type">int</span> a; </span><br><span class="line"><span class="type">char</span> b[<span class="number">20</span>]; </span><br><span class="line"><span class="type">double</span> c;</span><br><span class="line">&#125;A;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(a,b) (char*)(&amp;a.b)-(char*)(&amp;(a))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_OFFSET(data,member)      (size_t)(&amp;(((typeof(data)*)0)-&gt;member))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    A p;  <span class="comment">//定义结构体变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, offsetof(p,a)); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, offsetof(p,b)); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, GET_OFFSET(A,c));  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(A));  </span><br><span class="line"><span class="comment">//0</span></span><br><span class="line"><span class="comment">//4</span></span><br><span class="line"><span class="comment">//24</span></span><br><span class="line"><span class="comment">//32</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. typeof 关键字：</span></span><br><span class="line"><span class="comment">用于获取修饰修饰变量的数据类型。比如 int value； typeof( value ) 的作用是获得 value 的数据类型int 。</span></span><br><span class="line"><span class="comment">用法：</span></span><br><span class="line"><span class="comment">int value; 我想要定义一个 和value这个变量类型一样的新变量new_value ；</span></span><br><span class="line"><span class="comment">操作像这样： typeof(value) new_value ;</span></span><br><span class="line"><span class="comment">该用法可以用在函数的值传递中，在不知道值的类型的时候，可以定义和它类型相同的新变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. typedef :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">为数据类型起一个名字 ：比如 typedef struct student student_t ;</span></span><br><span class="line"><span class="comment">约定 ：一般新名字后面以 _t 结尾，表示是一个构造出来的新类型名字，便于理解。</span></span><br><span class="line"><span class="comment">student_t stud1 ; 等价于 struct student stud1 ; 很显然 前者更有利于移植和阅读。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3. (（data_type *）0) :</span></span><br><span class="line"><span class="comment">作用：把数字 0 强制转换成 （data_type） 类型的指针。</span></span><br><span class="line"><span class="comment">比如：( struct student * )0 的作用是把 0 转换成 struct student类型的指针，用于引用struct student数据类型类型的成员。</span></span><br><span class="line"><span class="comment">在这个题目中： ((typeof(data)*)0)-&gt;member 的目的是 把 0 转成 data 变量对应的数据类型的指针，然后通过该指针引用该类型的成员的值。</span></span><br><span class="line"><span class="comment">对于本题而言： (size_t)(&amp;(((struct student *)0)-&gt;d)) ： &amp; 用以获取struct student结构的成员d ,然后，获得d 的地址，将它转成 size_t 的数据类型量。</span></span><br><span class="line"><span class="comment">其中 size_t 的定义是 typedef unsigned int size_t ；</span></span><br><span class="line"><span class="comment">(size_t)(&amp;(((struct student *)0)-&gt;d)) 它的值是变量d的地址，为什么是偏移值呢？ 因为 起始地址我们认为规定为 0。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>定义一个宏以查找数组元素的总数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> vector_num(Array_name, type) sizeof(Array_name)/sizeof(type)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> arr1[<span class="number">10</span>];</span><br><span class="line"><span class="type">float</span> arr2[<span class="number">20</span>];</span><br><span class="line"><span class="type">double</span> arr3[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;num of arr1 is &quot;</span>&lt;&lt;<span class="built_in">vector_num</span>(arr1,<span class="type">int</span>)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;num of arr2 is &quot;</span>&lt;&lt;<span class="built_in">vector_num</span>(arr2,<span class="type">float</span>)&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;num of arr3 is &quot;</span>&lt;&lt;<span class="built_in">vector_num</span>(arr3,<span class="type">double</span>)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">num of arr1 is 10</span></span><br><span class="line"><span class="comment">num of arr2 is 20</span></span><br><span class="line"><span class="comment">num of arr3 is 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="82、容易造成缓冲区溢出的函数"><a href="#82、容易造成缓冲区溢出的函数" class="headerlink" title="82、容易造成缓冲区溢出的函数"></a>82、容易造成缓冲区溢出的函数</h3><p>1、strcpy()：字符串复制</p><p>2、strcat()：字符串连接</p><p>3、gets()：从输入流读取字符串到缓冲区</p><p>4、sprintf()：打印字符串到缓冲区</p><p>5、vsprintf()：打印字符串到缓冲区</p><p>6、scanf系列：从输入流读取格式化字符</p><p>7、strdup()：字符串复制</p><p><a href="https://blog.csdn.net/MOU_IT/article/details/89321475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163041825316780255296846%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163041825316780255296846&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89321475.first_rank_v2_pc_rank_v29&utm_term=%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E5%AE%B9%E6%98%93%E9%80%A0%E6%88%90%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA&spm=1018.2226.3001.4187">https://blog.csdn.net/MOU_IT/article/details/89321475?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163041825316780255296846%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163041825316780255296846&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-89321475.first_rank_v2_pc_rank_v29&amp;utm_term=%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E5%AE%B9%E6%98%93%E9%80%A0%E6%88%90%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA&amp;spm=1018.2226.3001.4187</a></p><h3 id="83、vector扩容"><a href="#83、vector扩容" class="headerlink" title="83、vector扩容"></a>83、vector扩容</h3><p>size():返回当前vector元素的个数。</p><p>capacity():返回当前vector中最大能够存储的元素的个数。</p><p>新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素；<br>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了 ；<br>初始时刻vector的capacity为0，塞入第一个元素后capacity增加为1；<br>不同的编译器实现的扩容方式不一样，VS2015中以1.5倍扩容，GCC以2倍扩容。</p><h3 id="84、typedef"><a href="#84、typedef" class="headerlink" title="84、typedef"></a>84、typedef</h3><p>我们想一次性声明两个char<em>的指针变量，但是结果却是声明了一个char</em>指针和一个char字符变量。<br>使用typedef声明后:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> * PCHAR;</span><br><span class="line">PCHAR p1, p2; <span class="comment">//可行，同时声明两个指向字符的指针</span></span><br></pre></td></tr></table></figure><p>使用typedef来声明结构体，能够简化代码。也可以用在声明类类型的别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT1</span> <span class="title">p1</span>;</span></span><br><span class="line"><span class="comment">/* C++中，则可以直接写：结构名 对象名，即：tagPOINT1 p1 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagPOINT</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;POINT;</span><br><span class="line">POINT p1; <span class="comment">// 这样就比原来的方式少写了一个struct，比较省事，尤其在大量使用的时候</span></span><br></pre></td></tr></table></figure><p>定义数组类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Array [<span class="number">100</span>]; </span><br><span class="line">Array a;<span class="comment">//相当于 int a[100];</span></span><br></pre></td></tr></table></figure><h3 id="85、指针数组和数组指针"><a href="#85、指针数组和数组指针" class="headerlink" title="85、指针数组和数组指针"></a>85、<strong>指针数组和数组指针</strong></h3><p><strong>指针数组</strong>：是指一个数组里面装着指针，是一个<strong>数组</strong>；<br>定义形式：<code>int *p[10]</code>；</p><p>数组指针 <em>:是指一个指向数组的指针，它其实还是一个指针，只不过是指向数组而已；<br>定义形式：<code>int (*p)[10]</code>；其中，由于[]的优先级高于</em>,所以必须添加(*p).</p><p><img src="H:\interview\interview_pic\指针数组和数组指针.jpg" alt="指针数组和数组指针"></p><h3 id="86、指针函数和函数指针"><a href="#86、指针函数和函数指针" class="headerlink" title="86、指针函数和函数指针"></a>86、指针函数和函数指针</h3><p>1、<strong>指针函数</strong>是指带指针的函数，即<strong>本质是一个函数</strong>，函数返回类型是某一类型的<strong>指针</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">f</span><span class="params">(x，y)</span>;</span><br><span class="line"><span class="comment">//首先它是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有函数返回值，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。</span></span><br></pre></td></tr></table></figure><p>2、<strong>函数指针</strong>是指向函数的指针变量<strong>，</strong>即<strong>本质是一个指针变量。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*fptr)();</span><br><span class="line"><span class="comment">//把函数的地址赋值给函数指针，可以采用下面两种形式： </span></span><br><span class="line">fptr=&amp;Function;</span><br><span class="line">fptr=Function;</span><br><span class="line"><span class="comment">//取地址运算符&amp;不是必需的，因为单单一个函数标识符就标号表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。</span></span><br></pre></td></tr></table></figure><h3 id="87、动态数组"><a href="#87、动态数组" class="headerlink" title="87、动态数组"></a>87、动态数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[i]; <span class="comment">//错误 因为在编译阶段，编译器并不知道 i 的值是多少</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维数组</span></span><br><span class="line"><span class="type">int</span> size = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> *p1 = new <span class="type">int</span>[size]; <span class="comment">//是正确的 </span></span><br><span class="line">delete[] p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维数组-1</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">50</span>;</span><br><span class="line"><span class="type">int</span>(*q)[<span class="number">50</span>] = new <span class="type">int</span>[a][<span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组-2</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>, y = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> **p2;</span><br><span class="line">p2 = new <span class="type">int</span>* [x];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">p2[i] = new <span class="type">int</span> [y];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; y; j++)</span><br><span class="line">p2[i][j] = i + j;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(p2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(p2[<span class="number">0</span>])&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">delete p2[i]; </span><br><span class="line">delete[] p2;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">//访问s[i][j]</span></span><br><span class="line"><span class="number">1</span>、*(&amp;s[<span class="number">0</span>][<span class="number">0</span>]+<span class="number">4</span> * i+j)</span><br><span class="line"><span class="number">2</span>、(*(s+i))[j]</span><br></pre></td></tr></table></figure><h3 id="88、左值和右值"><a href="#88、左值和右值" class="headerlink" title="88、左值和右值"></a>88、左值和右值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">左值是指可以出现在等号左边的变量或表达式，它最重要的特点就是可写（可寻址）。也就是说，它的值可以被修改，如果一个变量或表达式的值不能被修改，那么它就不能作为左值。</span><br><span class="line"></span><br><span class="line">右值是指只可以出现在等号右边的变量或表达式。它最重要的特点是可读。一般的使用场景都是把一个右值赋值给一个左值。</span><br><span class="line"></span><br><span class="line">通常，左值可以作为右值，但是右值不一定是左值。</span><br></pre></td></tr></table></figure><h3 id="89、C-在main-函数执行前，后执行了哪些操作"><a href="#89、C-在main-函数执行前，后执行了哪些操作" class="headerlink" title="89、C++在main()函数执行前，后执行了哪些操作"></a>89、C++在main()函数执行前，后执行了哪些操作</h3><p>c++在main函数运行前，需要进行一些操作，主要是初始化系统的相关资源<br>1、设置栈指针<br>2、初始化static静态和global全局变量，即data段的内容<br>3、将未初始化部分的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容<br>4、全局对象初始化，在main之前调用构造函数<br>5、将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数<br><strong>设置栈指针：</strong><br>为栈分配相关的位置，用来放一些局部变量和其他数据</p><p><strong>初始化静态和全局变量：</strong><br>把全局和静态变量初始化，放在相应的位置</p><p><strong>将未初始化的全局变量赋初值：</strong><br>将未设置初值的全局变量赋初值</p><p><strong>全局对象初始化：</strong><br>在main之前调用构造函数</p><p><strong>传值给main函数：</strong><br>argc为整数<br>argv为指针的指针</p><p><strong>在执行完main函数后：</strong><br>执行全局的析构函数</p><h3 id="90、堆和栈的区别"><a href="#90、堆和栈的区别" class="headerlink" title="90、堆和栈的区别"></a>90、堆和栈的区别</h3><p><strong>（1）管理方式不同。</strong>栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</p><p><strong>（2）空间大小不同。</strong>每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p><p><strong>（3）生长方向不同。</strong>堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</p><p><strong>（4）分配方式不同。</strong>堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。</p><p><strong>（5）分配效率不同。</strong>栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C&#x2F;C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</p><p><strong>（6）访问时间</strong>，访问堆的一个具体单元，需要两次访问内存，第一次得取得指针，第二次才是真正得数据，而栈只需访问一次。另外，堆的内容被操作系统交换到外存的概率比栈大，栈一般是不会被交换出去的。</p><p><strong>（7）存放内容不同。</strong>栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p><p>从以上可以看到，堆和栈相比，由于大量malloc()&#x2F;free()或new&#x2F;delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。</p><p>无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。</p><h3 id="91、为什么要有堆区"><a href="#91、为什么要有堆区" class="headerlink" title="91、为什么要有堆区"></a>91、为什么要有堆区</h3><p>堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，</p><p>栈区空间小</p><h3 id="92、四大智能指针"><a href="#92、四大智能指针" class="headerlink" title="92、四大智能指针"></a>92、四大智能指针</h3><p><strong>shared_ptr、unique_ptr、weak_ptr、auto_ptr</strong></p><p><strong>为什么要使用智能指针</strong>：智能指针的作用是管理一个指针，因为存在申请的空间在函数结束时忘记释放，造成内存泄漏的情况。使用智能指针可以很大程度上避免这个问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，自动释放资源。</p><h1 id="STM32"><a href="#STM32" class="headerlink" title="STM32"></a>STM32</h1><h2 id="1、stm32启动过程"><a href="#1、stm32启动过程" class="headerlink" title="1、stm32启动过程"></a>1、stm32启动过程</h2><blockquote><p>通过Boot引脚设定,寻找初始地址<br>初始化栈指针 __initial_sp<br>指向复位程序 Reset_Hander<br>设置异常中断 HardFault_Handler<br>设置系统时钟 SystemInit<br>调用C库函数 _main</p></blockquote><p><strong>1-</strong> 上电启动或者硬件复位</p><p><strong>2-</strong> 单片机从0x00地址开始执行程序，在执行程序前，单片机会根据BOOT引脚设置，将对应的存储器重映射到0x00处，如设置为BOOT0 &#x3D; 0 ，BOOT1 &#x3D; X 时，单片机将内部FLASH映射到0x00处，即将0X8000 0000地址映射到0X00处，单片机从FLASH中的程序启动，其他启动方式原理类似，相应的BOOT引脚设置如图</p><p><img src="H:\interview\interview_pic\boot.jpg" alt="boot"></p><p><strong>3-</strong> 跳转到存储有代码的存储介质（如FLASH）以后，第一个是——initial_sp,会先初始化堆栈指针，单片机首先找到的是一个中断向量表（向量表如下图所示），向量表第一个值是复位函数指针，它是用来初始化PC指针寄存器的，当PC指针寄存器初始化完成后，单片机会去执行复位函数</p><p><strong>4-</strong> 在复位函数中，首先执行系统时钟初始化函数初始化系统时钟，然后跳转到__main</p><p><img src="H:\interview\interview_pic\Reset_handler.jpg" alt="Reset_handler"></p><p><strong>5-</strong> 在_main函数中，会初始化内核的寄存器，如R0-R15，划分堆空间和栈空间，同时初始化程序数据，即将用户代码中的数据从FLASH中搬运到SRAM中，简单理解就是初始化全局变量(全部清0)（这也就是全局变量在C语言中不初始化也不会出现随机值的原因了）</p><h2 id="2、IIC"><a href="#2、IIC" class="headerlink" title="2、IIC"></a>2、IIC</h2><p>I2C 总线在物理连接上非常简单，分别由SDA(串行数据线)和SCL(串行时钟线)及上拉电阻组成。通信原理是通过对SCL和SDA线高低电平时序的控制，来产生I2C总线协议所需要的信号进行数据的传递。在总线空闲状态时，这两根线一般被上面所接的上拉电阻拉高，保持着高电平。</p><ul><li><p>IIC主设备功能：主要产生时钟，产生起始信号和停止信号</p></li><li><p>IIC从设备功能：可编程的IIC地址检测，停止位检测</p></li><li><p>**IIC的一个优点是它支持多主控(multimastering)**， 其中任何一个能够进行发送和接收的设备都可以成为主总线。一个主控能够控制信号的传输和时钟频率。当然，在任何时间点上只能有一个主控。</p></li><li><p><strong>SCL和SDA都需要接上拉电阻</strong> (大小由速度和容性负载决定一般在3.3K-10K之间) 保证数据的稳定性，减少干扰。</p></li><li><p><strong>IIC是半双工，而不是全双工</strong> ，同一时间只可以单向通信</p></li><li><p><strong>开始信号</strong>：SCL 为高电平时，SDA 由高电平向低电平跳变，开始传送数据。（下降沿）</p></li><li><p><strong>结束信号</strong>：SCL 为高电平时，SDA 由低电平向高电平跳变，结束传送数据。（上升沿）</p></li><li><p><strong>应答信号</strong>：接收数据的 IC 在接收到 8bit 数据后，向发送数据的 IC 发出特定的<strong>低电平</strong>脉冲，表示已收到数据。CPU 向受控单元发出一个信号后，等待受控单元发出一个应答信号，CPU 接收到应答信号后，根据实际情况作出是否继续传递信号的判断。若未收到应答信号，由判断为受控单元出现故障。</p></li><li><p>这些信号中，起始信号是必需的，结束信号和应答信号，都可以不要————————————————</p></li><li><p><strong>IIC信号在数据传输过程中，当SCL&#x3D;1高电平时，数据线SDA必须保持稳定状态，不允许有电平跳变，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。</strong></p></li></ul><p><img src="H:\interview\interview_pic\IIC时序图.png" alt="IIC时序图"></p><h2 id="3、SPI"><a href="#3、SPI" class="headerlink" title="3、SPI"></a>3、SPI</h2><ul><li><p>主机先将<code>NSS</code>信号拉低，这样保证开始接收数据；</p></li><li><p>当<strong>接收端</strong>检测到时钟的边沿信号时，它将立即读取<strong>数据线</strong>上的信号，这样就得到了一位数据（1<code>bit</code>）;</p></li><li><p><strong>主机</strong>发送到<strong>从机</strong>时：主机产生相应的时钟信号，然后数据<strong>一位一位</strong>地将从<code>MOSI</code>信号线上进行发送到从机；</p></li><li><p><strong>主机</strong>接收<strong>从机</strong>数据：如果从机需要将数据发送回主机，则主机将继续生成预定数量的时钟信号，并且从机会将数据通过<code>MISO</code>信号线发送；</p></li><li><p>SPI总线包括4条逻辑线，定义如下：</p><p>MISO：Master input slave output 主机输入，从机输出（数据来自从机）；</p><p>MOSI：Master output slave input 主机输出，从机输入（数据来自主机）；</p><p>SCLK ：Serial Clock 串行时钟信号，由主机产生发送给从机；</p><p>SS：Slave Select 片选信号，由主机发送，以控制与哪个从机通信，通常是低电平有效信号。</p></li><li><p>4种模式</p><p>Mode 0 CPOL&#x3D;0, CPHA&#x3D;0<br>Mode 1 CPOL&#x3D;0, CPHA&#x3D;1<br>Mode 2 CPOL&#x3D;1, CPHA&#x3D;0<br>Mode 3 CPOL&#x3D;1, CPHA&#x3D;1</p><p>时钟极性CPOL: 即SPI空闲时，时钟信号SCLK的电平（1:空闲时高电平; 0:空闲时低电平）<br>时钟相位CPHA: 即SPI在SCLK第几个边沿开始采样（0:第一个边沿开始; 1:第二个边沿开始）</p><p><img src="H:\interview\interview_pic\SPI相位极性.png" alt="SPI相位极性"></p></li></ul><p><img src="H:\interview\interview_pic\spi四种模式.png" alt="spi四种模式"></p><p><strong>SPI通讯的优势</strong></p><p>全双工串行通信；<br>高速数据传输速率;<br>简单的软件配置；<br>极其灵活的数据传输，不限于8位，它可以是任意大小的字；<br>非常简单的硬件结构。从站不需要唯一地址（与I2C不同）。从机使用主机时钟，不需要精密时钟振荡器&#x2F;晶振（与UART不同）。不需要收发器（与CAN不同）。</p><p><strong>SPI的缺点</strong><br>没有硬件从机应答信号（主机可能在不知情的情况下无处发送）；<br>通常仅支持一个主设备；<br>需要更多的引脚（与I2C不同）；<br>没有定义硬件级别的错误检查协议；<br>与RS-232和CAN总线相比，只能支持非常短的距离；<br><img src="H:\interview\interview_pic\SPI.png" alt="SPI"></p><h2 id="4、UART"><a href="#4、UART" class="headerlink" title="4、UART"></a>4、UART</h2><p><img src="H:\interview\interview_pic\UART.png" alt="UART"></p><p><strong>uart协议</strong></p><p><img src="H:\interview\interview_pic\UART协议.png" alt="UART协议"></p><p><strong>空闲位：</strong><br>UART协议规定，当总线处于空闲状态时信号线的状态为‘1’即高电平</p><p><strong>起始位：</strong><br>开始进行数据传输时发送方要先发出一个低电平’0’来表示传输字符的开始。因为空闲位一直是高电平所以开始第一次通讯时先发送一个明显区别于空闲状态的信号即为低电平。</p><p><strong>数据位：</strong><br>起始位之后就是要传输的数据，数据可以是5，6，7，8，9位，构成一个字符，一般都是8位。先发送<strong>最低位</strong>最后发送<strong>最高位</strong>。</p><p><strong>奇偶校验位：</strong><br>数据位传送完成后，要进行奇偶校验，校验位其实是调整个数，串口校验分几种方式：<br>1.无校验（no parity）<br>2.奇校验（odd parity）：如果数据位中’1’的数目是偶数，则校验位为’1’，如果’1’的数目是奇数，校验位为’0’。<br>3.偶校验（even parity）：如果数据为中’1’的数目是偶数，则校验位为’0’，如果为奇数，校验位为’1’。<br>4.mark parity：校验位始终为1<br>5.space parity：校验位始终为0</p><p><strong>停止位：</strong><br>数据结束标志，可以是1位，1.5位，2位的高电平。</p><p><strong>波特率：</strong><br>数据传输速率使用波特率来表示，单位bps（bits per second），常见的波特率9600bps，115200bps等等，其他标准的波特率是1200，2400，4800，19200，38400，57600。举个例子，如果串口波特率设置为9600bps，那么传输一个比特需要的时间是1&#x2F;9600≈104.2us。</p><p>UART每次传输完一个字节都会产生一次中断；</p><h2 id="5、通信协议对比"><a href="#5、通信协议对比" class="headerlink" title="5、通信协议对比"></a>5、通信协议对比</h2><p><img src="H:\interview\interview_pic\通信协议对比.png" alt="通信协议对比"></p><h2 id="6、哈佛结构和冯·诺依曼结构的区别"><a href="#6、哈佛结构和冯·诺依曼结构的区别" class="headerlink" title="6、哈佛结构和冯·诺依曼结构的区别"></a>6、哈佛结构和冯·诺依曼结构的区别</h2><p><strong>哈佛</strong></p><p>程序指令储存和数据储存分开，数据和指令的储存可以同时进行，可以使指令和数据有不同的数据宽度</p><p>哈佛结构的微处理器通常具有较高的执行效率。其程序指令和数据指令分开组织和储存的，执行时可以预先读取下一条指令</p><p><img src="H:\interview\interview_pic\哈佛.png" alt="哈佛"></p><p><strong>冯诺依曼</strong></p><p>「将程序指令和数据存储在一起」的存储器结构</p><p>计算机由5部分构成： 运算器、 控制器、 存储器、 输入和输出装置；</p><p><img src="H:\interview\interview_pic\冯诺依曼.png" alt="冯诺依曼"></p><h2 id="7、嵌入式系统的特点："><a href="#7、嵌入式系统的特点：" class="headerlink" title="7、嵌入式系统的特点："></a>7、嵌入式系统的特点：</h2><ul><li>专用型</li><li>隐蔽型</li><li>资源受限</li><li>高可靠性</li><li>软件固化</li><li>实时性</li></ul><h2 id="8、MOV寻址方式"><a href="#8、MOV寻址方式" class="headerlink" title="8、MOV寻址方式"></a>8、MOV寻址方式</h2><p>立即寻址 寄存器寻址 寄存器间接寻址 器相对寻址 堆栈址寻址 基址加变址寻址 多寄存器寻址</p><h2 id="9、CPU内部结构"><a href="#9、CPU内部结构" class="headerlink" title="9、CPU内部结构"></a>9、CPU内部结构</h2><p><img src="H:\interview\interview_pic\CPU内部结构.png" alt="CPU内部结构"></p><p>****控制单元****：控制单元是整个CPU的指挥控制中心，由程序计数器PC（Program Counter）, 指令寄存器IR(Instruction Register)、指令译码器ID(Instruction Decoder)和操作控制器OC(Operation Controller)等，对协调整个电脑有序工作极为重要。它根据用户预先编好的程序，依次从存储器中取出各条指令，放在指令寄存器IR中，通过指令译码(分析)确定应该进行什么操作，然后通过操作控制器OC，按确定的时序，向相应的部件发出微操作控制信号。操作控制器OC中主要包括节拍脉冲发生器、控制矩阵、时钟脉冲发生器、复位电路和启停电路等控制逻辑。</p><p>****运算单元****：是运算器的核心。可以执行算术运算(包括加减乘数等基本运算及其附加运算)和逻辑运算(包括移位、逻辑测试或两个值比较)。相对控制单元而言，运算器接受控制单元的命令而进行动作，即运算单元所进行的全部操作都是由控制单元发出的控制信号来指挥的，所以它是执行部件。</p><p>****存储单元****：包括CPU片内缓存和寄存器组，是CPU中暂时存放数据的地方，里面保存着那些等待处理的数据，或已经处理过的数据，CPU访问寄存器所用的时间要比访问内存的时间短。采用寄存器，可以减少CPU访问内存的次数，从而提高了CPU的工作速度。但因为受到芯片面积和集成度所限，寄存器组的容量不可能很大。寄存器组可分为专用寄存器和通用寄存器。专用寄存器的作用是固定的，分别寄存相应的数据。而通用寄存器用途广泛并可由程序员规定其用途，通用寄存器的数目因微处理器而异。这个是我们以后要介绍这个重点，这里先提一下。</p><p><img src="H:\interview\interview_pic\CPU工作原理.png" alt="CPU工作原理"></p><h2 id="10、异步传输与同步传输的区别"><a href="#10、异步传输与同步传输的区别" class="headerlink" title="10、异步传输与同步传输的区别"></a>10、<strong>异步传输与同步传输的区别</strong></h2><p>● 异步传输是面向字符传输的，而同步传输是面向位传输的。</p><p>● 异步传输的单位是字符，而同步传输的单位是大的数据块。</p><p>● 异步传输通过传输字符的“起止位”和“停止位”而进行收发双方的字符同步，但不需要每位严格同步;而同步传输不但需要每位精确同步，还需要在数据块的起始与终止位置，进行一个或多个同步字符的双方字符同步的过程。</p><p>● 异步传输相对于同步传输有效率低、速度低、设备便宜、适用低速场合等特点。</p><h2 id="11、ADC配置"><a href="#11、ADC配置" class="headerlink" title="11、ADC配置"></a>11、ADC配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、输入通道，IO口初始化 模拟输入（规则通道最多<span class="number">16</span>个，注入通道最多<span class="number">4</span>个）</span><br><span class="line"><span class="number">2</span>、ADC时钟分频 <span class="comment">//ADC 输入时钟 ADC_CLK 由 APB2 经过分频产生，最大值是 14MHz</span></span><br><span class="line"><span class="number">3</span>、转换顺序，使用多个通道进行转换就涉及到一个先后顺序<span class="comment">//SQR1、SQR2、SQR3</span></span><br><span class="line"><span class="number">4</span>、触发源 <span class="comment">//禁止触发检测、上升沿检测、下降沿检测以及上升沿和下降沿均检测</span></span><br><span class="line"><span class="number">5</span>、ADC 单次转换或者连续转换选择</span><br><span class="line"><span class="number">6</span>、ADC 扫描（多通道）或者单次 （单通道）模式选择</span><br><span class="line"><span class="number">7</span>、ADC 数据寄存器对齐格式</span><br><span class="line"><span class="number">8</span>、ADC 采集通道数</span><br><span class="line"><span class="number">9</span>、采样周期 <span class="number">239.5</span><span class="comment">// 转换时间=采样时间+12.5个周期 21us</span></span><br></pre></td></tr></table></figure><h2 id="12、定时器配置"><a href="#12、定时器配置" class="headerlink" title="12、定时器配置"></a>12、定时器配置</h2><p>stm32(STM32F103ZET6功能较为全面的一种)内部含有11个定时器：<strong>2个高级控制定时器（TIM1和TIM8）、4个通用定时器（TIMX：TIM2、TIM3、TIM4、TIM5）、2个基本定时器（TIM6和TIM7）</strong>，他们的功能性是依次减少的。</p><p>当计数模式为向上计数时：是从0开始向上计数，一直到计数值和重装载寄存器的数值相等时，计数器会自动归零，并产生一个溢出事件（也就是触发一次中断）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、选择时钟源</span><br><span class="line"><span class="number">2</span>、预分频系数<span class="comment">//0-65535，分频系数由于是除数，分母不能为 0， 所以会自动加 1，最后实现 1-65536 分频。</span></span><br><span class="line"><span class="number">3</span>、计数模式<span class="comment">//向上(0-ARR)、向下(ARR-0)、 中心对齐计数方式(0-ARR-0)。</span></span><br><span class="line"><span class="number">4</span>、自动重装载值 <span class="comment">//0 至 65535</span></span><br><span class="line"><span class="number">5</span>、时钟分频因子，设置定时器时钟 CK_INT 频率与数字 滤波器采样时钟频率分频比</span><br><span class="line"><span class="number">6</span>、中断优先级</span><br><span class="line"><span class="number">7</span>、中断类型 <span class="comment">//中断 TIM_IT_Update、触发中断 TIM_IT_Trigger、输入捕获中断</span></span><br><span class="line"><span class="number">8</span>、开启定时更新中断</span><br><span class="line">    当两个中断源的抢占式优先级相同时，这两个中断将没有嵌套关系，当一个中断到来后，如果正在处理另一个中断，这个后到来的中断就要等到前一个中断处理完之后才能被处理。如果这两个中断同时到达，则中断控制器根据他们的响应优先级高低来决定先处理哪一个；如果他们的抢占式优先级和响应优先级都相等，则根据他们在中断表中的排位顺序决定先处理哪一个。</span><br></pre></td></tr></table></figure><h2 id="13、PWM配置"><a href="#13、PWM配置" class="headerlink" title="13、PWM配置"></a>13、PWM配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、使能定时器及端口时钟，并设置引脚复用器映射<span class="comment">//复用推挽输出</span></span><br><span class="line"><span class="number">2</span>、初始化定时器参数,包含自动重装值，分频系数，计数方式<span class="comment">//向上(0-ARR)、向下(ARR-0)、 中心对齐计数方式(0-ARR-0)。</span></span><br><span class="line"><span class="number">3</span>、初始化 PWM 输出参数，</span><br><span class="line">    包含 PWM 模式<span class="comment">/*TIM_OCMode_PWM1、TIM_OCMode_PWM2 </span></span><br><span class="line"><span class="comment">Pwm1 CNT&lt;CCR为有效电平，CNT&gt;CCR为无效电平</span></span><br><span class="line"><span class="comment">Pwm2 CNT&lt;CCR为无效电平，CNT&gt;CCR为有效电平*/</span></span><br><span class="line">    输出极性<span class="comment">/*TIM_OCPolarity_Low、TIM_OCPolarity_High 设置有效电平*/</span></span><br><span class="line">    TIM_OutputState <span class="comment">//比较输出使能，用来使能 PWM 输出到 IO 口</span></span><br><span class="line"><span class="number">4</span>、修改 TIMx_CCRx 的值控制占空比</span><br><span class="line"><span class="number">5</span>、使能 TIMx 在 CCRx 上的预装载寄存器</span><br><span class="line">    <span class="type">void</span> <span class="title function_">TIM_OCxPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, <span class="type">uint16_t</span> TIM_OCPreload)</span>;</span><br><span class="line"><span class="number">6</span>、使能 TIMx 在 ARR 上的预装载寄存器允许位 </span><br><span class="line">    <span class="type">void</span> <span class="title function_">TIM_ARRPreloadConfig</span><span class="params">(TIM_TypeDef* TIMx, FunctionalState NewState)</span>;</span><br></pre></td></tr></table></figure><h2 id="14、串口配置"><a href="#14、串口配置" class="headerlink" title="14、串口配置"></a>14、串口配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、使能定时器及端口时钟，并设置引脚复用器映射 <span class="comment">//Tx复用推挽输出 Rx模拟输入</span></span><br><span class="line"><span class="number">2</span>、波特率，数据长度（<span class="number">5</span><span class="number">-9</span>），停止位，收发模式 <span class="comment">/*USART_Mode_Rx | USART_Mode_Tx*/</span> ，奇偶检验位</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    奇偶校验位：</span></span><br><span class="line"><span class="comment">    数据位传送完成后，要进行奇偶校验，校验位其实是调整个数，串口校验分几种方式：</span></span><br><span class="line"><span class="comment">    1.无校验（no parity）</span></span><br><span class="line"><span class="comment">    2.奇校验（odd parity）：如果数据位中’1’的数目是偶数，则校验位为’1’，如果’1’的数目是奇数，校验位为’0’。</span></span><br><span class="line"><span class="comment">    3.偶校验（even parity）：如果数据为中’1’的数目是偶数，则校验位为’0’，如果为奇数，校验位为’1’。</span></span><br><span class="line"><span class="comment">    4.mark parity：校验位始终为1</span></span><br><span class="line"><span class="comment">    5.space parity：校验位始终为0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="number">3</span>、使能串口，开启相关中断</span><br><span class="line"><span class="number">4</span>、配置中断优先级</span><br><span class="line">    <span class="comment">//数据长度 USART_WordLength_8b/USART_WordLength_9b</span></span><br><span class="line">    当有奇偶检验位时，需要<span class="number">8</span>个数据位加<span class="number">1</span>个校验位 设置 <span class="comment">//USART_InitStructure.USART_WordLength = USART_WordLength_9b</span></span><br><span class="line">    当无奇偶检验位时 设置<span class="comment">//USART_InitStructure.USART_WordLength = USART_WordLength_8b</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//UART每次传输完一个字节都会产生一次中断；</span></span><br><span class="line">    <span class="comment">//GND 要注意共地 负责很可能串口一直不出数据</span></span><br><span class="line">    <span class="comment">//波特率，校验位，数据长度等串口通讯的基本参数一定要匹配</span></span><br><span class="line">    <span class="comment">//发送完成标志位 USART_FLAG_TC</span></span><br></pre></td></tr></table></figure><h2 id="15、NVIC配置"><a href="#15、NVIC配置" class="headerlink" title="15、NVIC配置"></a>15、NVIC配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">0</span>组：  抢占优先级占<span class="number">0</span>位， 响应优先级占<span class="number">4</span>位</span><br><span class="line">  <span class="number">1</span>组：  抢占优先级占<span class="number">1</span>位， 响应优先级占<span class="number">3</span>位</span><br><span class="line">  <span class="number">2</span>组：  抢占优先级占<span class="number">2</span>位， 响应优先级占<span class="number">2</span>位</span><br><span class="line">  <span class="number">3</span>组：  抢占优先级占<span class="number">3</span>位， 响应优先级占<span class="number">1</span>位</span><br><span class="line">  <span class="number">4</span>组：  抢占优先级占<span class="number">4</span>位， 响应优先级占<span class="number">0</span>位 </span><br><span class="line">    NVIC_PriorityGroup_0 =&gt; 选择第<span class="number">0</span>组</span><br><span class="line">    NVIC_PriorityGroup_1 =&gt; 选择第<span class="number">1</span>组</span><br><span class="line">    NVIC_PriorityGroup_2 =&gt; 选择第<span class="number">2</span>组</span><br><span class="line">    NVIC_PriorityGroup_3 =&gt; 选择第<span class="number">3</span>组</span><br><span class="line">    NVIC_PriorityGroup_4 =&gt; 选择第<span class="number">4</span>组</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">具有高抢占式优先级的中断可以在具有低抢占式优先级的中断处理过程中被响应，即中断嵌套，或者说高抢占式优先级的中断可以嵌套低抢占式优先级的中断。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当两个中断源的抢占式优先级相同时，这两个中断将没有嵌套关系，当一个中断到来后，如果正在处理另一个中断，这个后到来的中断就要等到前一个中断处理完之后才能被处理。如果这两个中断同时到达，则中断控制器根据他们的响应优先级高低来决定先处理哪一个；==如果他们的抢占式优先级和响应优先级都相等，则根据他们在中断表中的排位顺序决定先处理哪一个。==</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="16、IIC配置"><a href="#16、IIC配置" class="headerlink" title="16、IIC配置"></a>16、IIC配置</h2><h2 id="17、SPI配置"><a href="#17、SPI配置" class="headerlink" title="17、SPI配置"></a>17、SPI配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、时钟源</span><br><span class="line"><span class="number">2</span>、GPIO端口初始化 推挽输出</span><br><span class="line"><span class="number">3</span>、设置单向或双向</span><br><span class="line"><span class="number">4</span>、设置主从模式</span><br><span class="line"><span class="number">5</span>、设置数据大小长度</span><br><span class="line"><span class="number">6</span>、CPOL、CPHA</span><br><span class="line"><span class="number">7</span>、片选信号<span class="comment">//SPI_NSS_Soft、SPI_NSS_Hard</span></span><br><span class="line"><span class="number">8</span>、设置速度</span><br><span class="line"><span class="number">9</span>、指定数据传输从MSB位还是LSB位开始</span><br><span class="line"><span class="number">10</span>、使能</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SPI总线注意点：</span><br><span class="line"><span class="number">1</span>、 Master配置SPI接口时钟的时候一定要考虑从设备的操作时序要求，因为Master这边的时钟极性和相位都是以Slave为基准的。因此在时钟极性的配置上一定要确定Slave是在SCK的下降沿还是上升沿输出数据，是在SCK的上升沿还是下降沿接收数据。</span><br><span class="line"><span class="number">2</span>、当Slave时钟频率小于Master时钟频率时，如果Master的SCK的速率太快，会出现Slave接收到的数据不正确，而SPI接口又没有应答机制确认Slave是否接收到数据从而导致通信传输数据错误。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="18、DMA配置"><a href="#18、DMA配置" class="headerlink" title="18、DMA配置"></a>18、DMA配置</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、发送外设地址和存储器地址</span><br><span class="line"><span class="number">2</span>、选择传输方向 <span class="comment">//存储器-外设 外设-存储器 存储器-存储器</span></span><br><span class="line"><span class="number">3</span>、设置数据长度 外设和存储器长度</span><br><span class="line"><span class="number">4</span>、设置模式 <span class="comment">//循环缓存模式、正常缓存模式</span></span><br><span class="line"><span class="number">5</span>、优先权 <span class="comment">// DMA_Priority_VeryHigh 、 DMA_Priority_High 、 DMA_Priority_Medium、DMA_Priority_Low  </span></span><br></pre></td></tr></table></figure><h2 id="19、交叉编译和交叉编译接口"><a href="#19、交叉编译和交叉编译接口" class="headerlink" title="19、交叉编译和交叉编译接口"></a>19、交叉编译和交叉编译接口</h2><p>交叉编译是在一个平台上生成另一个平台上的<a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81/9407947">可执行代码</a>。同一个<a href="https://baike.baidu.com/item/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/8174145">体系结构</a>可以运行不同的<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>；同样，同一个操作系统也可以在不同的体系结构上运行。</p><p>你在电脑上写程序，在电脑上编译出可执行文件，最后这个可执行文件需要下载到你的开发板上运行。程序最后运行的环境变了，比如你的开发板是基于 Arm 的——程序在 X86 上编辑，编译，最终运行在另一个和 X86 完全不同的架构的 Arm 芯片上。</p><h2 id="20、MCU上的固件，数据是怎么分配的"><a href="#20、MCU上的固件，数据是怎么分配的" class="headerlink" title="20、MCU上的固件，数据是怎么分配的"></a>20、MCU上的固件，数据是怎么分配的</h2><p>首先单片机的内存可以大小分为ram和rom，这里就不再解释ram和rom的区别了，我们可以将其等效为flash和sram，其中根据sram和flash的定义可得，flash里面的数据掉电可保存，sram中的并不可以，但是sram的执行速度要快于flash，可以将单片机的程序分为code(代码存储区)、RO-data(只读数据存储区)、RW-data(读写数据存储区)和ZI-data(零初始化数据区)。</p><p><strong>Code</strong>：代码占用的空间大小（占用的空间为内部Flash）<br><strong>RO-data</strong>：只读常量大小（const常量，#define宏常量。一般用于不需要更改的数据）<br><strong>RW-data</strong>：初始化了的变量大小 上电后会从FLASH搬移到RAM中<br><strong>ZI-data</strong> ：没有初始化的变量大小</p><p><strong>Total RO  Size</strong> (Code + RO Data)<br>**Total RW  Size **(RW Data + ZI Data)<br>**Total ROM Size **(Code + RO Data + RW Data) ：程序下载到ROM FLASH中的大小<br>为什么Rom中还要存RW，因为掉电后RAM中所有数据都丢失了，每次上电RAM中的数据是被重新赋值的，每次这些固定的值就是存储在Rom中的，为什么不包含ZI段呢，是因为ZI数据都是0，没必要包含，只要程序运行之前将ZI数据所在的区域一律清零即可，包含进去反而浪费存储空间。</p><p>烧写完的时：<strong>FLASH</strong>大小 ：Code + RO Data + RW Data<br>运行的时候： <strong>RAM</strong>大小 ： RW Data + ZI Data，当然还要有堆栈的空间。</p><h2 id="21、ARM寄存器"><a href="#21、ARM寄存器" class="headerlink" title="21、ARM寄存器"></a>21、ARM寄存器</h2><p><strong>ARM</strong> 处理器一般共有 <strong>37</strong> <strong>个寄存器，其中包括：</strong></p><p>（1） 31 个通用寄存器，包括 PC（程序计数器）在内，都是 32 位的寄存器。<br>（2） 6 个状态寄存器，都是 32 位的寄存器。</p><p> 其中 r0<del>r3 主要用于子程序间传递参数， r4</del>r11 主要用于保存局部变量，但在 Thumb 程序中，通常只能使用 r4~r7 来保存局部变量； r12 用作子程序间scratch 寄存器，即 ip 寄存器； r13 通常用做栈指针，即 sp； r14 寄存器又被称为连接寄存器（lr），用于保存子程序以及中断的返回地址；</p><p>寄存器R13在ARM指令中常用作<strong>堆栈指针SP</strong>,但这只是一种习惯用法，当程序的运行进入异常模式时，可以****将需要保护的寄存器放入R13所指向的堆栈*<em><strong>，而当程序从异常模式返回时，则从对应的堆栈中恢复，采用这种方式可以</strong></em>*保证异常发生后程序的正常执行****。</p><p>R14：为<strong>链接寄存器</strong>（Link Register，LR），两种用法：<br>1、每一种处理器模式下物理地址R14存放当前子程序的返回地址。<br>2、当异常发生时，该异常模式特定的物理R14被设置成该异常模式将要返回的地址。对于有些异常模式，R14的值可能与将返回的地址有一个常数的偏移量。</p><p> R15： 用作<strong>程序计数器</strong><br>由于 ARM 采用了流水线机制，当正确读取了 PC 的值后，该值为当前指令地址加 8 个字节，即 PC 指向当前指令的下两条指令地址</p><p>寄存器R16<br>寄存器R16用作CPSR(<strong>程序状态寄存器</strong>)，CPSR可在任何运行模式下被访问，它包括条件标志位、中断禁止位、当前处理器模式标志位，以及其他一些相关的控制和状态位。<br>每一种运行模式下又都有一个专用的物理状态寄存器，称为SPSR(Saved Program Status Register，备份的程序状态寄存器)，当异常发生时，SPSR用于保存CPSR的当前值，从异常退出时则可由SPSR来恢复CPSR。</p><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1 线性表"></a>1 线性表</h2><blockquote><p>线性表是具有相同特性的数据元素的一个有限序列</p><p>有穷性、一致性、序列性</p></blockquote><h3 id="1-1-顺序表"><a href="#1-1-顺序表" class="headerlink" title="1.1 顺序表"></a>1.1 顺序表</h3><p>线性表中的所有元素按照其逻辑顺序依次存储（线性表的顺序存储结构称为顺序表）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elemtype data[Maxsize];<span class="comment">//存放线性表中的元素</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//存放线性表的长度ls</span></span><br><span class="line">&#125;Sqlist;</span><br></pre></td></tr></table></figure><p>查找元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(Sqlist *L, Elemtype e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;L-&gt;length &amp;&amp; L-&gt;data[i]!=e)</span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;= L-&gt;length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入数据元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(Sqlist *&amp;L, <span class="type">int</span> i, Elemtype e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span> || L-&gt;length == Maxsize)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//参数i错误返回</span></span><br><span class="line">    i--;</span><br><span class="line">    <span class="keyword">for</span>(j=L-&gt;length; j&gt;i; j--) <span class="comment">//元素后移</span></span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;data[j] = L-&gt;data[j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">    L-&gt;data[j] = e;<span class="comment">//插入元素</span></span><br><span class="line">    L-&gt;length++;<span class="comment">//顺序表长度+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-单链表"><a href="#1-2-单链表" class="headerlink" title="1.2 单链表"></a>1.2 单链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elemtype data;<span class="comment">//存放元素</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//指向后继结点</span></span><br><span class="line">&#125;ListNode;</span><br></pre></td></tr></table></figure><p>遍历链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">list_show</span><span class="params">(<span class="keyword">struct</span> ListNode *l)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(l!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;l-&gt;data&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">        l=l-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>头插法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">first_insert</span><span class="params">(<span class="keyword">struct</span> ListNode *first,<span class="type">int</span> data)</span></span><br><span class="line">&#123;    </span><br><span class="line">    ListNode *p = new (<span class="keyword">struct</span> ListNode);</span><br><span class="line">    p-&gt;data = data;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(first==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;next = first;</span><br><span class="line">        first = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode *<span class="title function_">last_insert</span><span class="params">(<span class="keyword">struct</span> ListNode *first,<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ListNode* last = <span class="literal">NULL</span>;</span><br><span class="line">    last = first;</span><br><span class="line"></span><br><span class="line">    ListNode *p = new (<span class="keyword">struct</span> ListNode);</span><br><span class="line">    p-&gt;data = data;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(first == <span class="literal">NULL</span>)<span class="comment">//链表还没有第一个节点</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//说明要插入的节点是第一个节点</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;       </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(last-&gt;next!= <span class="literal">NULL</span>) <span class="comment">//找到最后一个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        last = last-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    last-&gt;next = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从中间插入数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">insert</span><span class="params">(ListNode *&amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    ListNode *p = L, *s;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;i<span class="number">-1</span> &amp;&amp; p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        j++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = (ListNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">        s-&gt;data = e;</span><br><span class="line">        s-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = s;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Delete</span><span class="params">(ListNode *&amp;L, <span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    ListNode *p = L;</span><br><span class="line">    <span class="keyword">if</span>(pos == <span class="number">0</span>) &#123;</span><br><span class="line">        L = L-&gt;next; <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;pos<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-双链表"><a href="#1-3-双链表" class="headerlink" title="1.3 双链表"></a>1.3 双链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>* <span class="title">prior</span>;</span></span><br><span class="line">&#125;DLinkNode;</span><br></pre></td></tr></table></figure><p>头插法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DLinkNode* <span class="title function_">fisrt_insert</span><span class="params">(DLinkNode *L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DLinkNode *s;</span><br><span class="line">    s = new DLinkNode; </span><br><span class="line"></span><br><span class="line">    s-&gt;data = data;</span><br><span class="line">    s-&gt;next = nullptr;</span><br><span class="line">    s-&gt;prior = nullptr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(L==nullptr)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;prior = s; </span><br><span class="line">        s-&gt;next = L;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尾插法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DLinkNode* <span class="title function_">last_insert</span><span class="params">(DLinkNode *L, <span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    DLinkNode *p = L;</span><br><span class="line">    DLinkNode *s = new DLinkNode;</span><br><span class="line"></span><br><span class="line">    s-&gt;data = data;</span><br><span class="line">    s-&gt;next = nullptr;</span><br><span class="line">    s-&gt;prior = nullptr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(L==nullptr)</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(L-&gt;next)</span><br><span class="line">            L=L-&gt;next;<span class="comment">//找到尾结点</span></span><br><span class="line">        L-&gt;next = s; </span><br><span class="line">        s-&gt;prior = L;        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2 栈和队列"></a>2 栈和队列</h2><h3 id="2-1-栈"><a href="#2-1-栈" class="headerlink" title="2.1 栈"></a>2.1 栈</h3><blockquote><p>单端操作，先进后出</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data[maxsize];</span><br><span class="line"><span class="type">int</span> top;<span class="comment">//栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="comment">//栈空：top = -1;  </span></span><br><span class="line"><span class="comment">//栈满：top = maxsize-1;(从0下标开始)</span></span><br></pre></td></tr></table></figure><p>进栈push</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(SqStack *&amp;s, <span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s-&gt;top == maxsize<span class="number">-1</span>) <span class="comment">//栈满</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">s-&gt;top++;</span><br><span class="line">s-&gt;data[s-&gt;top] = e;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出栈pop</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">push</span><span class="params">(SqStack *&amp;s, <span class="type">int</span> &amp;e)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(s-&gt;top == <span class="number">-1</span>) <span class="comment">//栈空</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">e = s-&gt;data[s-&gt;top]; <span class="comment">//取栈顶元素</span></span><br><span class="line">s-&gt;top--;<span class="comment">//栈顶指针减1</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-队列"><a href="#2-2-队列" class="headerlink" title="2.2 队列"></a>2.2 队列</h3><blockquote><p>双端操作, 先进先出</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> data[maxsize];</span><br><span class="line"><span class="type">int</span> front,rear;<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="comment">//初始值 front=rear=-1;  进队 rear++  出队 front++</span></span><br><span class="line"><span class="comment">//队空 q-&gt;front == q-&gt;rear;</span></span><br><span class="line"><span class="comment">//队满 q-&gt;rear == maxSize - 1; </span></span><br></pre></td></tr></table></figure><h3 id="2-3环形队列"><a href="#2-3环形队列" class="headerlink" title="2.3环形队列"></a>2.3环形队列</h3><p>环形队列少用一个元素空间，最多只能有maxsize-1 个元素</p><p>初始值 ： front&#x3D;rear &#x3D; 0;</p><p>队空：rear &#x3D;&#x3D; front;</p><p>队满： (rear+1)%maxsize &#x3D;&#x3D; front</p><p>元素个数：（rear - front + maxsize）%maxsize</p><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3 递归"></a>3 递归</h2><blockquote><p>能够递归解决的3个条件</p><p>① 需要解决的问题可以转化为一个或多个子问题来求解，而这些子问题的求解方法与原问题完全相同，只是在数量规模上不同</p><p>② 递归调用的次数有限</p><p>③ 必须有结束条件来终止递归</p></blockquote><h2 id="4-树和二叉树"><a href="#4-树和二叉树" class="headerlink" title="4 树和二叉树"></a>4 树和二叉树</h2><h3 id="4-1-二叉树"><a href="#4-1-二叉树" class="headerlink" title="4.1 二叉树"></a>4.1 二叉树</h3><p>二叉树是一个有限的结点集合，要么为空，要么有。。。。。。。</p><h3 id="4-2满二叉树"><a href="#4-2满二叉树" class="headerlink" title="4.2满二叉树"></a>4.2满二叉树</h3><p>满就对了  一颗高度h的满二叉树，含有2^h-1个结点</p><p>特点</p><blockquote><p>最有最后一层有叶子节点</p><p>不存在度为一的结点</p><p>结点i的左孩子为2i，右孩子为2i+1；结点i的父节点为i&#x2F;2（向上取整）</p></blockquote><h3 id="4-3-完全二叉树"><a href="#4-3-完全二叉树" class="headerlink" title="4.3 完全二叉树"></a>4.3 完全二叉树</h3><h3 id="4-4-线索二叉树"><a href="#4-4-线索二叉树" class="headerlink" title="4.4 线索二叉树"></a>4.4 线索二叉树</h3><p>将左右孩子指针指向前驱后继结点</p><p>![](F:\C Pic\Saved Pictures\Snipaste_2021-08-07_15-42-10.png)</p><h3 id="4-5-二叉排序、二叉查找、二叉搜索树"><a href="#4-5-二叉排序、二叉查找、二叉搜索树" class="headerlink" title="4.5  二叉排序、二叉查找、二叉搜索树"></a>4.5  二叉排序、二叉查找、二叉搜索树</h3><blockquote><p>左 &lt; 根  &lt; 右</p></blockquote><p>![image-20210807161029963](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210807161029963.png)</p><p>查找最好时间复杂度O(logN)，最坏时间复杂度O(N)。<br>插入删除操作算法简单，时间复杂度与查找差不多。</p><h3 id="4-6-平衡二叉树"><a href="#4-6-平衡二叉树" class="headerlink" title="4.6 平衡二叉树"></a>4.6 平衡二叉树</h3><blockquote><p>结点的平衡因子 &#x3D; 左子树高  - 右子树高   平衡因子绝对值不超过1 的树为平衡二叉树</p><p>为了提高二叉排序树的查找效率，O（log2n）</p></blockquote><p>![image-20210808161154158](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210808161154158.png)</p><p>![image-20210808161210480](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210808161210480.png)</p><blockquote><p>平衡二叉树插入结点 找出最小不平衡子树</p><p>LL型 右旋</p><p>RR型 左旋</p><p>LR型 先左旋，在右旋</p><p>RL型 先右旋，再左旋</p></blockquote><h3 id="4-7-哈夫曼树"><a href="#4-7-哈夫曼树" class="headerlink" title="4.7 哈夫曼树"></a>4.7 哈夫曼树</h3><blockquote><p>结点带权路径长度：从树的根节点到该节点的路径长度与该节点上权值的成绩</p><p>树的带权路径长度：树中所有叶子结点的带权路径长度之和 (WPL)</p></blockquote><p>![image-20210808163952963](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210808163952963.png)</p><p>![image-20210808164000536](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210808164000536.png)</p><blockquote><p>带权路径长度最小的二叉树称为哈夫曼树 也称最优二叉树</p></blockquote><h3 id="4-8-B树"><a href="#4-8-B树" class="headerlink" title="4.8 B树"></a>4.8 B树</h3><p>![image-20210808171800743](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210808171800743.png)</p><p>①每个结点的关键字 [m&#x2F;2]-1 &lt;&#x3D; n &lt;&#x3D; m-1  （向上取整）  根节点除外</p><p>③ 每个结点的孩子 [m&#x2F;2] &lt;&#x3D; n &lt;&#x3D; m  根节点除外</p><p>② 根节点取值范围  1&lt;&#x3D; n &lt;&#x3D; m-1</p><h3 id="4-9-B-树"><a href="#4-9-B-树" class="headerlink" title="4.9 B+树"></a>4.9 B+树</h3><p>![image-20210808171719089](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210808171719089.png)</p><p>1、每个分支结点最多有m棵子树</p><p>2、非叶根节点至少有两颗子树，其他每个分支节点至少有[m&#x2F;2]棵子树</p><p>3、结点的子树个数与关键字个数相等</p><p>4、所有叶节点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小排序，并且相邻叶结点按大小顺序相互链接起来 </p><p><strong>B树和B+树的区别</strong></p><p>① 在B+树中，具有n个关键字的结点含有n棵子树，即 每个关键字对应一颗子树；</p><p>​在B树中，具有n个关键字的结点含有n+1棵子树</p><p>② B+树中，除根节点外，关键字取值范围 [m&#x2F;2]&lt;&#x3D; n &lt;&#x3D; m , 根节点n的取值范围为 2&lt;&#x3D; n &lt;&#x3D; m;</p><p>​B树中，除根节点外，关键字取值范围 [m&#x2F;2]-1 &lt;&#x3D; n &lt;&#x3D; m-1 , 根节点n的取值范围为 1&lt;&#x3D; n &lt;&#x3D; m-1;</p><p>③ B+中所有叶子节点包含了全部关键字，即其他非叶子节点中的关键字也包含在叶子结点中，而在B树中关键字是不重复的</p><p>④ B+树中的所有非叶子节点只起到索引的作用，即结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。而在B树中，每个关键字都对应一个记录的存储地</p><h3 id="4-10-红黑树"><a href="#4-10-红黑树" class="headerlink" title="4.10 红黑树"></a>4.10 红黑树</h3><p>1.节点是红色或黑色。</p><p>2.根节点是黑色。</p><p>3.每个叶子节点都是黑色的空节点（NIL节点）。</p><p>4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个<strong>连续</strong>的红色节点)</p><p>5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</p><p><img src="H:\interview\interview_pic\红黑树.png" alt="红黑树"></p><h2 id="5-堆"><a href="#5-堆" class="headerlink" title="5.堆"></a>5.堆</h2><p>堆是一种常用的树形结构，是一种特殊的完全二叉树，当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。堆的这一特性称之为堆序性。因此，在一个堆中，根节点是最大（或最小）节点。如果根节点最小，称之为小顶堆（或小根堆），如果根节点最大，称之为大顶堆（或大根堆）。</p><p>![image-20210917163113454](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210917163113454.png)</p><h2 id="排序算法复杂度"><a href="#排序算法复杂度" class="headerlink" title="排序算法复杂度"></a>排序算法复杂度</h2><p><img src="H:\interview\interview_pic\排序算法复杂度1.png" alt="排序算法复杂度"></p><p><img src="H:\interview\interview_pic\时间复杂度比较.jpg" alt="时间复杂度比较"></p><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n)</p><h1 id="Linux操作系统"><a href="#Linux操作系统" class="headerlink" title="Linux操作系统"></a>Linux操作系统</h1><h2 id="1、预读入缓输出"><a href="#1、预读入缓输出" class="headerlink" title="1、预读入缓输出"></a>1、预读入缓输出</h2><p>![image-20210810230925508](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210810230925508.png)</p><p>系统调用不一定币库函数调用快fputc内部有一个缓冲区，正常情况写满4096在调用系统函数写入内核  ，而write函数每次只写1个数据，导致切换内核空间和用户空间的次数比fputc多4096倍。</p><h2 id="2、内存布局图"><a href="#2、内存布局图" class="headerlink" title="2、内存布局图"></a>2、内存布局图</h2><p><img src="H:\interview\interview_pic\内存布局图1.png"></p><h2 id="3、虚拟内存和物理内存"><a href="#3、虚拟内存和物理内存" class="headerlink" title="3、虚拟内存和物理内存"></a>3、虚拟内存和物理内存</h2><p><img src="H:\interview\interview_pic\虚拟内存和物理内存.png" alt="虚拟内存和物理内存"></p><blockquote><p>用户区的数据在物理内存映射到不同区域</p><p>不同进程的pcb进程块映射到同一内存地址 因为内核实质上为操作系统 操作系统只有一份</p></blockquote><h2 id="4、bootloader启动过程"><a href="#4、bootloader启动过程" class="headerlink" title="4、bootloader启动过程"></a>4、bootloader启动过程</h2><p><strong>Bootloader启动的两个阶段</strong>：<strong>stage1</strong> 和 <strong>stage2</strong>两大部分。 stage1 主要是一些依赖于 CPU 体系结构的代码。这一阶段的代码主要是通过汇编来实现的。 stage1 为位置无关代码，通常在Flash 中运行。所以有的指令为相对寻址，可以在任何位置运行。stage2 则是通常用 C 语言来实现，这样可以实现更复杂的功能，而且代码 会具有更好的可读性和可移植性。</p><p><strong>stage1负责的主要任务有：</strong><br>   ① 硬件设备初始化包括：关闭Watchdog、关闭中断、设置 CPU 的速度和时钟频率、初始化内存控制器、配置SDRAM 存储控制器及 IO、关闭处理器内部指令&#x2F;数据 Cache 等；<br>   ② 为加载Bootloader 的 stage2 代码准备 RAM ；<br>   ③ 复制 Bootloader的 stage2 代码到 RAM 中；<br>   ④ 设置堆栈；<br>   ⑤ 跳转到 stage2的 C 函数入口点。</p><p><strong>stage2 负责的主要任务有：</strong><br>    ① 初始化本阶段要使用到的硬件设备（如串口、Flash和网卡等）；<br>    ② 系统的内存映射检测；<br>    ③ 加载内核映像和文件系统映像；<br>    ④ 设置内核启动参数；<br>    ⑤ 调用内核。</p><p>Bootloader 调用内核的方法就是直接跳转到内核的第一条指令处。在调用内核之前下列的条件必须要满足：</p><p>（1） CPU 寄存器的设置</p><p>​① R0 为 0；<br>​    ② R1 为机器码；<br>​    ③ R2 为启动参数，标记列表在RAM 中的起始基地址</p><p>（2）CPU 工作模式<br>    ① 必须禁止中断（ IRQ 和 FIQ）；<br>    ② CPU 必须设置为 SVC 模式。</p><p>（3）Cache 和 MMU 的设置<br>    ① MMU 必须关闭；<br>    ② 指令 Cache 可以打开或关闭；<br>    ③ 数据 Cache 必须关闭。</p><h2 id="5、进程状态"><a href="#5、进程状态" class="headerlink" title="5、进程状态"></a>5、进程状态</h2><p>进程的状态，有（初始）就绪、运行、挂起、停止等状态。</p><h2 id="6、虚拟内存"><a href="#6、虚拟内存" class="headerlink" title="6、虚拟内存"></a>6、虚拟内存</h2><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存，如Windows家族的“虚拟内存”；Linux的“交换空间”等。虚拟内存技术主要有以下优点：虚拟内存可以大于物理内存，一般为物理内存的1.5倍到3倍，从而可以运行比物理内存大的程序，进而使得更多的程序可以同时执行，提高了多道程序的程度，增加了CPU的使用率，并且使得进程之间的独立性得到了更好的体现。</p><h2 id="7、TCP和UDP的区别"><a href="#7、TCP和UDP的区别" class="headerlink" title="7、TCP和UDP的区别"></a>7、TCP和UDP的区别</h2><p><img src="H:\interview\interview_pic\TCP和UDP.png" alt="TCP和UDP"></p><h2 id="8、三次握手和四次挥手"><a href="#8、三次握手和四次挥手" class="headerlink" title="8、三次握手和四次挥手"></a>8、三次握手和四次挥手</h2><ul><li>第一次握手: 可以确认客服端的发送能力</li><li>第二次握手: 可以确认服务端的接收能力 和 发送能力</li><li>第三次握手: 可以确认客户端的接收能力</li></ul><p><img src="H:\interview\interview_pic\三次握手.png" alt="三次握手"></p><p><strong>SYN：同步序号。</strong>它表示建立连接。TCP规定SYN&#x3D;1时不能携带数据，但要消耗一个序号, 因此随机选取一个序列号为seq&#x3D;x 数据包（该数据包里就是一个标记seq，并没有任何有效的数据）。</p><p><strong>ACK ：确认序号。</strong>它表示响应（都能响应了 那肯定上一步就连接成功了啊，所以说ACK&#x3D;1代表确认连接成功啦）。</p><p>因此SYN和ACK同时为1，表示建立连接之后的响应；而只是单个的SYN&#x3D;1，表示的只是建立连接。</p><p><strong>seq： (sequence number) 序列号。</strong>它是发送端数据包的初始序号。seq&#x3D;x 表示发送端数据包的初始序号为x（seq &#x3D; 0 就代表这是第0号帧）。</p><p><strong>ack：(acknowledge number) 确认号</strong>。它是对这次收到数据包的确认，以及对下次收到数据包的期待。ack&#x3D;x+1表示 我方 到 x为止的所有数据都已正确收到，且我方告知 对方：我期待你下次给我发送包的初始序号(seq)是x+1。</p><p><img src="H:\interview\interview_pic\四次挥手.png" alt="四次挥手"></p><p><strong>四次挥手释放连接时，等待2MSL的意义?</strong></p><ul><li>保证客户端发送的最后一个ACK报文段能够到达服务端。</li><li>防止“已失效的连接请求报文段”出现在本连接中。</li></ul><p>客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。</p><h2 id="9、TCP协议-如何保证传输可靠性"><a href="#9、TCP协议-如何保证传输可靠性" class="headerlink" title="9、TCP协议-如何保证传输可靠性"></a>9、TCP协议-如何保证传输可靠性</h2><p>TCP协议保证数据传输可靠性的方式主要有：</p><ul><li><p>校验和</p></li><li><p>序列号</p></li><li><p>确认应答</p></li><li><p>超时重传</p><p>发送方没有介绍到响应的ACK报文原因可能有两点：</p><ol><li>数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。</li><li>接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。</li></ol><p>TCP在解决这个问题的时候引入了一个新的机制，叫做超时重传机制。简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。</p></li><li><p>连接管理（三次握手四次挥手）</p></li><li><p>流量控制（滑动窗口）</p></li><li><p>拥塞控制</p><p><a href="https://www.cnblogs.com/losbyday/p/5847041.html">https://www.cnblogs.com/losbyday/p/5847041.html</a></p></li></ul><p><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162890851416780269816952%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162890851416780269816952&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-80428157.first_rank_v2_pc_rank_v29&utm_term=TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7&spm=1018.2226.3001.4187">https://blog.csdn.net/liuchenxia8/article/details/80428157?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162890851416780269816952%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=162890851416780269816952&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-80428157.first_rank_v2_pc_rank_v29&amp;utm_term=TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7&amp;spm=1018.2226.3001.4187</a></p><p><strong>流量控制和拥塞控制</strong></p><p>拥塞控制：<strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</strong>拥塞控制所要做的都有一个<strong>前提：网络能够承受现有的网络负荷。</strong>拥塞控制是一个<strong>全局性的过程</strong>，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p><p>  流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><h2 id="10、CPU和MMU"><a href="#10、CPU和MMU" class="headerlink" title="10、CPU和MMU"></a>10、CPU和MMU</h2><p><img src="H:\interview\interview_pic\CPU.png" alt="CPU"></p><h2 id="11、线程共享资源"><a href="#11、线程共享资源" class="headerlink" title="11、线程共享资源"></a>11、线程共享资源</h2><p><strong>线程共享资源</strong></p><p>1.文件描述符表</p><p>2.每种信号的处理方式</p><p>3.当前工作目录</p><p>4.用户 ID 和组 ID</p><p>5.内存地址空间 (.text&#x2F;.data&#x2F;.bss&#x2F;heap&#x2F;共享库)</p><p><strong>线程非共享资源</strong></p><p>1.线程 id</p><p>2.处理器现场和栈指针(内核栈)</p><p>3.独立的栈空间(用户空间栈)</p><p>4.errno 变量</p><p>5.信号屏蔽字</p><p>6.调度优先级</p><h2 id="12、进程共享资源"><a href="#12、进程共享资源" class="headerlink" title="12、进程共享资源"></a>12、进程共享资源</h2><p><strong>刚 fork 之后：</strong></p><p>**父子相同处: **全局变量、.data、.text、栈、堆、环境变量、用户 ID、宿主目录、进程工作目录、信号处理方式…</p><p>**父子不同处: **1.进程 ID 2.fork 返回值 3.父进程 ID 4.进程运行时间 5.闹钟(定时器) 6.未决信号集</p><p>父子进程间遵循<strong>读时共享写时复制</strong>的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。 </p><h2 id="13、进程间通信的方式"><a href="#13、进程间通信的方式" class="headerlink" title="13、进程间通信的方式"></a>13、进程间通信的方式</h2><p>管道</p><blockquote><p>实现原理： 内核借助环形队列机制，使用内核缓冲区实现。<br>管道读写行为：<br>管道局限性：1.数据不能反复读取  2.半双工通信，单向流动  3.血缘关系<br>SIGPIPE： 向一个没有读端的管道写数据。默认动作为终止进程。</p></blockquote><p>命名管道</p><blockquote><p>可以用于无血缘关系的进程间通信</p></blockquote><p>消息队列</p><p>信号</p><blockquote><p>信号是进程给操作系统或进程的某种信息，让操作系统或者其他进程针对这个信号做出指定反应。<br>所有信号的产生及处理全部都是由<strong>内核</strong>完成的</p></blockquote><p>信号量</p><blockquote><p>信号量的使用主要是用来保护共享资源，使得资源在一个时刻只有一个进程（线程）所拥有。<br>信号量的值为正的时候，说明它空闲。所测试的线程可以锁定而使用它。若为0，说明它被占用，测试的线程要进入睡眠队列中，等待被唤醒。<br>多个线程间对某一对象的部分数据进行共享<br>sem_wait() –操作     sem_post() ++操作</p></blockquote><p>共享内存映射</p><blockquote><p>将一个指定文件映射到存储区域中<br>最常用也是最快<br>优点：返回void * ，可以操作自定义类型数据<br>缺点：有很多的注意事项（文件大小，文件读写属性、映射区属性）</p></blockquote><p>socket套接字</p><h2 id="14、线程间同步方式"><a href="#14、线程间同步方式" class="headerlink" title="14、线程间同步方式"></a>14、线程间同步方式</h2><p><strong>锁机制</strong>：包括互斥锁、条件变量、读写锁和自旋锁。</p><blockquote><p>  互斥锁确保同一时间只能有一个线程访问共享资源。当锁被占用时试图对其加锁的线程都进入阻塞状态(释放CPU资源使其由运行状态进入等待状态)。当锁释放时哪个等待线程能获得该锁取决于内核的调度。</p></blockquote><blockquote><p>读写锁：rwlock，分为读锁和写锁。处于读操作时，可以允许多个线程同时获得读操作。但是同一时刻只能有一个线程可以获得写锁。其它获取写锁失败的线程都会进入睡眠状态，直到写锁释放时被唤醒。 注意：写锁会阻塞其它读写锁。当有一个线程获得写锁在写时，读锁也不能被其它线程获取；写者优先于读者。<strong>适用于读取数据的频率远远大于写数据的频率的场合。</strong></p></blockquote><blockquote><p>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p></blockquote><blockquote><p>  自旋锁：spinlock，在任何时刻同样只能有一个线程访问对象。但是当获取锁操作失败时，不会进入睡眠，而是会在原地自旋，直到锁被释放。这样节省了线程从睡眠状态到被唤醒期间的消耗，在<strong>加锁时间短暂的环境</strong>下会极大的提高效率。但如果加锁时间过长，则会非常浪费CPU资源。</p></blockquote><p>**信号量机制(Semaphore)**：包括无名线程信号量和命名线程信号量</p><p>**信号机制(Signal)**：类似进程间的信号处理</p><h2 id="15、OSI七层模型"><a href="#15、OSI七层模型" class="headerlink" title="15、OSI七层模型"></a>15、OSI七层模型</h2><p><img src="H:\interview\interview_pic\OSI七层模型和TCP四层模型.png" alt="OSI七层模型和TCP四层模型"></p><p><img src="H:\interview\interview_pic\OSI七层模型.png" alt="OSI七层模型"></p><h2 id="16、进程和线程的区别"><a href="#16、进程和线程的区别" class="headerlink" title="16、进程和线程的区别"></a>16、<strong>进程和线程的区别</strong></h2><p>1.一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。线程依赖于进程而存在。</p><p>2.进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。）</p><p>3.<strong>进程是资源分配的最小单位，线程是CPU调度的最小单位；</strong></p><p>4.系统开销：由于在创建或撤消进程时，系统都要为之分配或回收资源，如内存空间、I／O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。类似地，在进行进程切换时，涉及到整个当前进程CPU环境的保存以及新被调度运行的进程的CPU环境的设置。而线程切换只须保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作。可见，进程切换的开销也远大于线程切换的开销。</p><p>5.通信：由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易。进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。在有的系统中，<strong>线程的切换、同步和通信都无须操作系统内核的干预</strong></p><ol start="6"><li>多进程逻辑控制比多线程复杂，需要与主进程做好交互。根据上面几点，我们不难知道多进程是“要用来做大事”的，而多线程是“各自做件小事，合作完成大 事”。所以要做大事自然就需要更复杂的逻辑控制，不像做小事那么目标明显。</li></ol><p>7.进程间不会相互影响 ；线程一个线程挂掉将导致整个进程挂掉</p><p>8.多进程通讯因为需要跨越进程边界，不适合大量数据的传送，更适合小数据或者密集数据的传送。而多线程无需跨越进程边界，适合各线程间大量数据的传送，甚至还有很重要的一点，多线程可以共享同一进程里的共享内存和变量哦。</p><p><img src="H:\interview\interview_pic\多进程多进程优缺点.png" alt="多进程多进程优缺点"></p><h2 id="17、并发和并行"><a href="#17、并发和并行" class="headerlink" title="17、并发和并行"></a>17、并发和并行</h2><p>并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。</p><p>并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。</p><h2 id="18、进程状态转换转换图"><a href="#18、进程状态转换转换图" class="headerlink" title="18、进程状态转换转换图"></a>18、进程状态转换转换图</h2><p><img src="H:\interview\interview_pic\进程状态的转换.png" alt="进程状态的转换"></p><p><img src="/.%5Cinterview_pic%5C%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E5%92%8C%E8%BD%AC%E6%8D%A2.png" alt="进程状态和转换"></p><p><img src="H:\interview\interview_pic\进程状态的转换1.png" alt="进程状态的转换1"></p><h2 id="19、父子进程共享"><a href="#19、父子进程共享" class="headerlink" title="19、父子进程共享"></a>19、父子进程共享</h2><p><strong>父子进程共享内容：</strong></p><p>刚 fork 后。 data 段、text 段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、信号处理方式</p><p><strong>父子进程不同内容</strong>：</p><p>进程 id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</p><h2 id="20、一个线程最多可以创建多少线程"><a href="#20、一个线程最多可以创建多少线程" class="headerlink" title="20、一个线程最多可以创建多少线程"></a>20、一个线程最多可以创建多少线程</h2><p>ulimit -u 查看进程上限</p><p>ulimit -a 查看文件打开上限</p><p>我们知道了创建一个线程会占用多少内存，这取决于分配给线程的调用栈大小，可以用ulimit -s命令来查看大小，显示的单位是KB（一般常见的有10M或者是8M，也可以临时修改）。我们还知道，一个进程的虚拟内存是4G，在Linux32位平台下，内核分走了1G，留给用户用的只有3G，于是我们可以想到，创建一个线程占有了10M内存，总共有3G内存可以使用。于是可想而知，最多可以创建差不多300个左右的线程。</p><h2 id="21、同步与互斥"><a href="#21、同步与互斥" class="headerlink" title="21、同步与互斥"></a>21、同步与互斥</h2><p><strong>互斥：指在某一时刻指允许一个进程运行其中的程序片，具有排他性和唯一性。</strong></p><blockquote><p>对于线程A和线程B来讲，在同一时刻，只允许一个线程对临界资源进行操作，即当A进入临界区对资源操作时，B就必须等待；当A执行完，退出临界区后，B才能对临界资源进行操作。</p></blockquote><p><strong>同步：指的是在互斥的基础上，实现进程之间的有序访问。</strong></p><blockquote><p>假设现有线程A和线程B，线程A需要往缓冲区写数据，线程B需要从缓冲区读数据，但他们之间存在一种制约关系，即当线程A写的时候，B不能来拿数据；B在拿数据的时候A不能往缓冲区写，也就是说，只有当A写完数据（或B取走数据），B才能来读数据（或A才能往里写数据）。这种关系就是一种线程的同步关系</p></blockquote><p><strong>互斥可以看成是一种特殊的线程同步。</strong></p><p><strong>互斥锁与信号量的区别？</strong></p><p><strong>答</strong>：互斥锁用于线程的互斥，信号量用于线程的同步。这是互斥锁和信号量的根本区别，也就是互斥和同步之间的区别。同时互斥锁的作用域仅仅在于线程，信号量可以作用于线程和进程。</p><h2 id="22、临界资源和临界区"><a href="#22、临界资源和临界区" class="headerlink" title="22、临界资源和临界区"></a>22、临界资源和临界区</h2><ul><li>临界资源：能够被多个线程共享的数据&#x2F;资源。</li><li>临界区：对临界资源进行操作的那一段代码</li></ul><h2 id="23、并发，同步，互斥，异步，阻塞，非阻塞"><a href="#23、并发，同步，互斥，异步，阻塞，非阻塞" class="headerlink" title="23、并发，同步，互斥，异步，阻塞，非阻塞"></a>23、并发，同步，互斥，异步，阻塞，非阻塞</h2><p><strong>同步</strong>：分布在不同进程之间的若干程序片断，它们的运行必须严格按照规定的某种<strong>先后次序</strong>来运行，这种先后次序依赖于要完成的特定的任务。所以同步就是在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。同步就是顺序执行，执行完一个再执行下一个，需要等待、协调运行。</p><p><strong>异步</strong>：异步和同步是相对的，异步就是<strong>彼此独立</strong>,在等待某事件的过程中继续做自己的事，不需要等待这一事件完成后再工作。</p><p><strong>线程同步与阻塞的关系</strong></p><ul><li><strong>同步是个过程，阻塞是线程的一种状态</strong>：当多个线程访问同一资源时，规定同一时间只有一个线程可以进行访问，所以后访问的线程将阻塞，等待前访问的线程访问完。</li><li><strong>线程同步不一定发生阻塞！线程同步的时候，需要协调推进速度，只有当访问同一资源出现互相等待和互相唤醒会发生阻塞</strong></li></ul><h2 id="24、孤儿进程和僵尸进程"><a href="#24、孤儿进程和僵尸进程" class="headerlink" title="24、孤儿进程和僵尸进程"></a>24、孤儿进程和僵尸进程</h2><p><strong>僵尸进程</strong>：即子进程先于父进程退出后，子进程的PCB需要其父进程释放，但是父进程并没有释放子进程的PCB，这样的子进程就称为僵尸进程</p><p><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p><p>孤儿进程与僵尸进程不同的是，由于父进程已经死亡，系统会帮助父进程回收处理孤儿进程。所以孤儿进程实际上是不占用资源的，因为它终究是被系统回收了。不会像僵尸进程那样占用ID,损害运行系统。</p><p><strong>僵尸进程处理方式</strong>：</p><p>1）一种比较暴力的做法是将其父进程杀死，那么它的子进程，即僵尸进程会变成孤儿进程，由系统来回收。但是这种做法在大多数情况下都是不可取的，如父进程是一个服务器程序，如果为了回收其子进程的资源，而杀死服务器程序，那么将导致整个服务器崩溃，得不偿失。显然这种回收进程的方式是不可取的，但其也有一定的存在意义。</p><p>2）SIGCHLD信号处理</p><p>我们都知道wait函数是用来处理僵尸进程的，但是进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。我们先来看看wait函数的定义</p><h2 id="25、Linux内核的组成"><a href="#25、Linux内核的组成" class="headerlink" title="25、Linux内核的组成"></a>25、Linux内核的组成</h2><p>UNIX系统由内核、shell、文件系统（系统调用和共用函数库）和应用程序等4部分组成。</p><p><img src="H:\interview\interview_pic\linux系统组成.png" alt="linux系统组成"></p><p>Linux内核主要由5个子系统组成</p><ul><li>进程调度子系统</li><li>内存管理子系统</li><li>虚拟文件子系统</li><li>网络接口子系统</li><li>进程间通信子系统</li></ul><p>Linux内核的主要模块分以下几个部分：</p><ul><li>存储管理</li><li>CPU和进程管理</li><li>文件系统</li><li>设备管理和驱动</li><li>网络通信</li><li>系统的初始化（引导）</li><li>系统调用</li></ul><h2 id="26、用户空间与内核通信方式有哪些？"><a href="#26、用户空间与内核通信方式有哪些？" class="headerlink" title="26、用户空间与内核通信方式有哪些？"></a>26、用户空间与内核通信方式有哪些？</h2><p> 1)首先想到的是系统调用，用户空间进程通过系统调用进入内核空间，访问指定的内核空间数据；</p><p>   2).其次是驱动程序，用户空间进程可以使用封装后的系统调用接口访问驱动设备节点，以和运行在内和空间的驱动程序通信；</p><p>   3).共享内存mmap，在代码中调用接口，实现内核空间与用户空间的地址映射，在实时性要求很高的项目中为首选，省去拷贝数据的时间等资源，但缺点是不好控制；</p><p>   4).最后，copy_to_user()、copy_from_user()，是在驱动程序中调用接口，实现用户空间与内核空间的数据拷贝操作，应用于实时性要求不高的项目中。</p><h2 id="27、系统调用的作用"><a href="#27、系统调用的作用" class="headerlink" title="27、系统调用的作用"></a>27、系统调用的作用</h2><p>(1)  系统调用可以为用户空间提供访问硬件资源的统一接口，以至于应用程序不必去关 注具体的硬件访问操作。比如，读写文件时，应用程序不用去管磁盘类型，甚至于不用关心是哪种文件系统。</p><p>(2)  系统调用可以对系统进行保护，保证系统的稳定和安全。系统调用的存在规定了用 户进程进入内核的具体方式，换句话说，用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的进入内核的统一访问路径限制才能保证 内核的安全。</p><p><strong>系统调用的过程</strong></p><p><strong>通知内核的机制是靠软中断实现的:通过引发一个异常来促使系统切换到内核态去执行异常处理程序。此时的异常处理程序实际上就是系统调用处理程序</strong>。</p><ul><li><strong>保存上下文</strong>(用户态执行)</li><li><strong>用eax保存系统调用号，用其他寄存器保存传递的参数</strong>，在x86-32系统上，ebx、 ecx、 edx、 esi 和edi按照顺序存放前五个参数。(内核态执行)</li><li><strong>系统调用必须仔细检查它们所有的参数是否合法有效</strong>。与进程相关的函数必须检查提供的PID是否有效。必须检查每个参数，保证它们不但合法有效，而且正确。进程不应当让内核去访问那些它无权访问的资源。然后触发<strong>0x80中断</strong>，首先执行system_call 函数，然后通过eax寄存器<strong>将系统调用号传递给内核</strong>，内核通过eax的系统调用号在<strong>系统调用表里找到相应的系统调用函数。</strong></li><li>执行该系统调用函数。(内核态执行)</li><li>执行完毕后，转入ret_from_sys_call 例程，从系统调用返回到用户态。</li></ul><h2 id="28、BootLoader、内核和根文件系统之间的关系"><a href="#28、BootLoader、内核和根文件系统之间的关系" class="headerlink" title="28、BootLoader、内核和根文件系统之间的关系"></a>28、BootLoader、内核和根文件系统之间的关系</h2><ol><li><strong>bootloader</strong><br>对于bootloader，我们一般用u-boot来制作。<strong>初始化硬件设备</strong><br>当开发板烧写了u-boot并启动后，你可以使用命令行来控制开发板进行一些简单硬件操作和配置（内存、网络、文件系统和启动等等），并且命令风格和linux很相似，所以也可以把u-boot看作一个封装了各种硬件外设驱动（裸机）的Shell程序。<br>由于u-boot集成了网络功能（如tftp工具），因此开发板在烧写好u-boot后，我们可以通过网络上传linux内核，将kernel镜像文件直接加载开发板内存中去，达到动态加载的目的，这样就不用非得先把kernel烧写到mmc和sd卡中再去加载和执行。使用u-boot可以直接将内存中的镜像文件写入mmc和sd卡，也可以从mmc和sd卡将镜像读到内存中。</li><li><strong>kernel</strong><br> kernel的启动依赖于bootLoader，因此需要用u-boot来引导和加载我们的内核镜像。使用u-boot的boot相关命令能够启动linux kernel。当kernel启动完毕的时候，u-boot就完成了它的任务，把命令行让给linux内核。</li><li><strong>rootfs</strong><br> kernel的正常运行要求有一个根文件系统rootfs，这个根文件系统存放了linux系统的一些重要文件、库、命令等，内核启动后需要对其进行挂载。</li></ol><h2 id="39、为什么需要Bootloader？"><a href="#39、为什么需要Bootloader？" class="headerlink" title="39、为什么需要Bootloader？"></a>39、为什么需要Bootloader？</h2><p>每种不同的CPU体系结构都有不同的Bootloader。除了依赖于CPU的体系结构外，Bootloader还依赖于具体的嵌入式板级设备的配置，比如板卡的硬件地址分配，外设芯片类型等。也就是说，对于两块不同的开发板而言，即使他们是基于同一种CPU而构建的，但是如果他们的硬件资源或配置不一致的话，想要在一块开发板上运行Bootloader程序也能在另一块板子上运行，还是需要做修改。</p><h2 id="30、ps命令"><a href="#30、ps命令" class="headerlink" title="30、ps命令"></a>30、ps命令</h2><p>ps ajx</p><p>![image-20210906092427104](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210906092427104.png)</p><p>ps aux</p><p>![image-20210906092445433](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210906092445433.png)</p><h2 id="31、linux下检查内存状态的命令"><a href="#31、linux下检查内存状态的命令" class="headerlink" title="31、linux下检查内存状态的命令"></a>31、linux下检查内存状态的命令</h2><p>**free  **</p><p>![image-20210906091446166](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210906091446166.png)</p><p>**top **</p><p>![image-20210906091906559](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210906091906559.png)</p><p><strong>df -h</strong></p><p>![image-20210906091947146](C:\Users\And I\AppData\Roaming\Typora\typora-user-images\image-20210906091947146.png)</p><h2 id="32、死锁的原因、条件"><a href="#32、死锁的原因、条件" class="headerlink" title="32、死锁的原因、条件"></a>32、死锁的原因、条件</h2><p><strong>产生死锁的四个必要条件：</strong></p><p>　　<strong>● 互斥条件</strong>：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p><p>　　<strong>● 请求与保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><p>　　<strong>● 不可剥夺条件</strong>：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</p><p>　　<strong>● 循环等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p><p><strong>产生死锁的原因：</strong><br>1.竞争资源。当系统中供多个进程共享的资源如打印机，公用队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。</p><p>2.进程推进顺序非法。进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。</p><p>如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。</p><p><img src="H:\interview\interview_pic\两种死锁.png" alt="两种死锁"></p><p><strong>预防死锁：</strong><br>资源一次性分配，加锁时序：（破坏请求和保持条件）<br>可剥夺资源：即当某进程新的资源未满足时，释放已占有的资源（破坏不可剥夺条件）<br>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</p><p><strong>避免死锁</strong>：银行家算法。</p><p><strong>检测死锁</strong><br>首先为每个进程和每个资源指定一个唯一的号码；之后我们可以建立一个有向图:(类似二分图)</p><p>如果a持有b资源，那么从A向B构造一个有向边，如果a要使用b资源，b向a构造一个有向边，如果这个图出现了一个环，那么二分图构造失败，会发生死锁</p><p><strong>解除死锁:</strong><br>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来，常采用的方法有：<br>剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；<br>撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态.消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。</p><h2 id="33、软链接和硬链接"><a href="#33、软链接和硬链接" class="headerlink" title="33、软链接和硬链接"></a>33、软链接和硬链接</h2><p><strong>软连接</strong></p><p>ln -s file file.s 创建一个软链接</p><p>Linux 下的软链接行为和 windows 下的快捷方式差不多，但是如果是用相对路径创建的软链接，在软链接移动之后就会失效，无法访问。这一点和 windows 快捷方式不同，windows 快捷方式随便放哪里都行</p><p>软链接的权限指的是这个软链接本身的权限，不是软链接指向文件的权限</p><p><strong>硬链接</strong></p><p>ln file file.h 创建一个硬链接</p><p>创建硬链接后，文件的硬链接计数+1</p><p>无论更改哪个硬链接或者文件本身，这三个文件的<strong>变化同步</strong></p><p>产生这种同步变化的原因：可以看到文件和硬链接的 Inode 是相同的，每个文件都有唯一的 Inode，直观理解起来就像C++里面的引用，对于同一个文件，无论有多少引用，在访问时，都是这个文件，所以修改就是同步的。</p><h2 id="34、计算机中，32bit与64bit有什么区别"><a href="#34、计算机中，32bit与64bit有什么区别" class="headerlink" title="34、计算机中，32bit与64bit有什么区别"></a>34、计算机中，32bit与64bit有什么区别</h2><p><strong>表示:</strong><br>32bit: X86<br>64bit: X 64</p><p><strong>处理数据的能力:</strong><br>32位计算机的CPU一次最多能bai处理32位数据，例如它的EAX寄存器就是32位的，32位计算机通常也可以处理16位和8位数据。64位计算机一次处理数据要比32位大得多，一次运行64位的数据。</p><p>1.32位系统的最大寻址空间是2的32次方&#x3D;4294967296(bit)&#x3D; 4(GB)左右;</p><p>2.64位系统的最大寻址空间为2的64次方方，数值大于1亿GB;</p><p>3.也就是说32位系统的处理器最大只支持到4G内存，而64位系统最大支持的内存高达亿位数，实际运用过程中大多数的电脑32位系统最多识别3.5GB内存，64位系统最多识别128GB内存。</p><p><strong>支持的内存不同(寻址能力不同):</strong><br>32位的系统许多支持4G的内存，而64位则可以支持上百G的内存。</p><p><strong>架构不同:</strong><br>从32位到64位架构的改变是一个根本的改变，因为大多数操作系统必须进行全面性修改，以取得新架构的优点。其它软件也必须进行移植，以使用新的性能;较日的软件一般可借由硬件兼容模式(新的处理器支持较日的32位版本指令集)或软件模拟进行支持。<br>或者直接在64位处理器里面实作32位处理器内核(如同Intel的ltanium处理器，其内含有x86处理器内核，用来执行32位x86应用程序)。支持64位架构的操作系统，一般同时支持32位和64位的应用程序。</p><p><strong>对配置的要求不同:</strong><br>64位操作系统只能安装在64位电脑上(CPU必须是64位的)。同时需要安装64位常用软件以发挥64位(x64)的最佳性能。32位操作系统则可以安装在32位(32位CPU)或64位(64位CPU)电脑上。</p><h2 id="35、中断和异常的区别"><a href="#35、中断和异常的区别" class="headerlink" title="35、中断和异常的区别"></a>35、中断和异常的区别</h2><p>下图 表示中断时 CPU 的活动轨迹。还可进一步把中断分为外中断和内中断。</p><ul><li><strong>外中断</strong>——就是我们指的中断——是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等；</li><li><strong>内中断</strong>——就是<strong>异常</strong>——是指由于 CPU 内部事件所引起的中断，如程序出错(非法指令、地址越界)。内中断(trap)也被译为“捕获”或“陷入”。</li><li>异常是由于执行了现行指令所引起的。由于系统调用引起的中断属于异常。</li><li>中断则是由于系统中某事件引起的，该事件与现行指令无关。</li></ul><p><strong>中断和异常</strong></p><p><strong>相同点：</strong>都是<strong>CPU</strong>对<strong>系统</strong>发生的某<strong>个事情</strong>做出的<strong>一种反应</strong>。</p><p> <strong>区别：中断</strong>由<strong>外因引起</strong>，<strong>异常</strong>由<strong>CPU本身</strong>原因引起。</p><h2 id="36、中断处理大概流程"><a href="#36、中断处理大概流程" class="headerlink" title="36、中断处理大概流程"></a>36、中断处理大概流程</h2><p>请求中断→响应中断→关闭中断→保留断点→中断源识别→保护现场→中断服务子程序→恢复现场→中断返回。</p><p><strong>请求中断：</strong>当某一中断源需要CPU为其进行中断服务时，就输出中断请求信号，使中断控制系统的中断请求触发器置位，向CPU请求中断。系统要求中断请求信号一直保持到CPU对其进行中断响应为止；</p><p><strong>中断响应：</strong>CPU对系统内部中断源提出的中断请求必须响应，而且自动取得中断服务子程序的入口地址，执行中断服务子程序。对于外部中断，CPU在执行当前指令的最后一个时钟周期去查询INTR引脚，若查询到中断请求信号有效，同时在系统开中断（即IF&#x3D;1）的情况下，CPU向发出中断请求的外设回送一个低电平有效的中断应答信号，作为对中断请求INTR的应答，系统自动进入中断响应周期；</p><p><strong>保护现场：</strong>主程序和中断服务子程序都要使用CPU内部寄存器等资源，为使中断处理程序不破坏主程序中寄存器的内容，应先将断点处各寄存器的内容（主要是当前IP（将要执行的下一条地址）和CS值（代码段地址））压入堆栈保护起来，再进入的中断处理。现场保护是由用户使用PUSH指令来实现的；</p><p><strong>中断服务：</strong>中断服务是执行中断的主体部分，不同的中断请求，有各自不同的中断服务内容，需要根据中断源所要完成的功能，事先编写相应的中断服务子程序存入内存，等待中断请求响应后调用执行；</p><p><strong>恢复现场：</strong>当中断处理完毕后，用户通过POP指令将保存在堆栈中的各个寄存器的内容弹出，即恢复主程序断点处寄存器的原值。</p><p><strong>中断返回：</strong>在中断服务子程序的最后要安排一条中断返回指令IRET（interrupt return），执行该指令，系统自动将堆栈内保存的IP（将要执行的下一条地址）和CS值（代码段地址）弹出，从而恢复主程序断点处的地址值，同时还自动恢复标志寄存器FR或EFR的内容，使CPU转到被中断的程序中继续执行。</p><h2 id="37、什么时候会发生段错误"><a href="#37、什么时候会发生段错误" class="headerlink" title="37、什么时候会发生段错误"></a>37、什么时候会发生段错误</h2><p>1）、使用了野指针</p><p>如：char *s ;</p><p>strcpy(s,”abcd”);  &#x2F;&#x2F; 错误！！— 会出现不可预知的错误，因为这时的s是野指针！—- 编译会通过，因为编译器无法察觉野指针，但执行时会段错误！</p><p>（2）、对试图对字符串常量的内容进行修改</p><p>如：char *s &#x3D; “1234”;</p><p>strcpy(s,”abcd”); &#x2F;&#x2F; 错误！！，因为s指向的空间是字符串常量的空间—- 编译会通过，但执行时会段错误！</p><p>而对const变量的值的修改、或是通过常量指针对指向内容的修改只是会报错而已，并不会段错误，</p><h2 id="38、栈溢出几种情况"><a href="#38、栈溢出几种情况" class="headerlink" title="38、栈溢出几种情况"></a>38、栈溢出几种情况</h2><p>一、局部数组过大。当函数内部的数组过大时，有可能导致堆栈溢出。</p><p>二、递归调用层次太多。递归函数在运行时会执行压栈操作，当压栈次数太多时，也会导致堆栈溢出。</p><p>三、指针或数组越界。这种情况最常见，例如进行字符串拷贝，或处理用户输入等等。</p><h2 id="39、什么是进程上下文、中断上下文"><a href="#39、什么是进程上下文、中断上下文" class="headerlink" title="39、什么是进程上下文、中断上下文"></a>39、<strong>什么是进程上下文、中断上下文</strong></h2><p>所谓的进程上下文，就是一个进程在执行的时候<strong>，CPU的所有寄存器中的值、进程的状态以及堆栈中的内容</strong>，当内核需要切换到另一个进程时，它需要保存当前进程的所有状态，即保存当前进程的进程上下文，以便再次执行该进程时，能够恢复切换时的状态，继续执行。</p><h2 id="40、内核态，用户态的区别"><a href="#40、内核态，用户态的区别" class="headerlink" title="40、内核态，用户态的区别"></a>40、<strong>内核态，用户态的区别</strong></h2><p><strong>解析：</strong></p><p>   系统态(也称为管态或核心态)，操作系统在系统态运行——运行操作系统程序!</p><p>  用户态(也称为目态)，应用程序只能在用户态运行——运行用户程序</p><p>   当一个进程在执行用户自己的代码时处于用户运行态（用户态），此时特权级最低，为3级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。Ring3状态不能访问Ring0的地址空间，包括代码和数据；当一个进程因为系统调用陷入内核代码中执行时处于内核运行态（内核态），此时特权级最高，为0级。执行的内核代码会使用当前进程的内核栈，每个进程都有自己的内核栈。</p><p>  用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，然后进入3G-4G中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。</p><p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有较高的特权级。运行在用户态的程序不能直接访问操作系统内核数据结构和程序。内核态和用户态之间的转换方式主要包括：系统调用，异常和中断。</p><h2 id="41、管道"><a href="#41、管道" class="headerlink" title="41、管道"></a>41、管道</h2><p>管道：pipe 创建并打开 读端和写端</p><p>实现原理： 内核借助环形队列机制，使用内核缓冲区实现。</p><p>特质； 1. 伪文件</p><p>​\2. 管道中的数据只能一次读取。</p><p>​\3. 数据在管道中，只能单向流动。</p><p>局限性：1. 自己写，不能自己读。</p><p>​\2. 数据不可以反复读。</p><p>​\3. 半双工通信。</p><p>​\4. 血缘关系进程间可用。</p><p>管道的读写行为：</p><p>读管道：</p><p>\1. 管道有数据，read 返回实际读到的字节数。</p><p>\2. 管道无数据： 1）无写端，read 返回 0 （类似读到文件尾）</p><p>​2）有写端，read 阻塞等待。</p><p>写管道：</p><p>\1. 无读端， 异常终止。 （SIGPIPE 导致的）</p><p>\2. 有读端： 1） 管道已满， 阻塞等待</p><p>​2） 管道未满， 返回写出的字节个数。</p><h2 id="42、互斥量底层"><a href="#42、互斥量底层" class="headerlink" title="42、互斥量底层"></a>42、互斥量底层</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Linux 中提供一把互斥锁 mutex（也称之为互斥量）。</span><br><span class="line">是用来保护临界区(critical section)的。所谓临界区就是代码的一个区间，如果两个线程同时执行就有可能出问题，所以需要互斥锁来保护。</span><br><span class="line">每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。 资源还是共享的，线程间也还是竞争的， 但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了</span><br></pre></td></tr></table></figure><h2 id="43、信号量底层"><a href="#43、信号量底层" class="headerlink" title="43、信号量底层"></a>43、信号量底层</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">由于互斥锁的粒度比较大，如果我们希望在多个线程间对某一对象的部分数据进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。</span><br><span class="line">信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</span><br></pre></td></tr></table></figure><h2 id="44、如何测试上万条并发量的"><a href="#44、如何测试上万条并发量的" class="headerlink" title="44、如何测试上万条并发量的"></a>44、如何测试上万条并发量的</h2><p>如果一万个客户端连接上，同时请求图片，其中有客户端随机挂掉，服务器如何回收资源</p><h2 id="45、linux驱动"><a href="#45、linux驱动" class="headerlink" title="45、linux驱动"></a>45、linux驱动</h2><h2 id="46、服务器客户端创建过程"><a href="#46、服务器客户端创建过程" class="headerlink" title="46、服务器客户端创建过程"></a>46、服务器客户端创建过程</h2><p><strong>TCP</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">socket -&gt; (bzero) -&gt; bind -&gt; listen -&gt; accept -&gt; read &lt;-&gt; write -&gt; close</span><br><span class="line">client:</span><br><span class="line">socket -&gt; connect -&gt; write &lt;-&gt; read -&gt; close</span><br></pre></td></tr></table></figure><p><strong>UDP</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server：</span><br><span class="line">socket -&gt; bind -&gt; listen(可有可无) -&gt; recvfrom &lt;-&gt; sendto -&gt; close</span><br><span class="line">client:</span><br><span class="line">socket -&gt; sendto &lt;-&gt; recvfrom -&gt; close</span><br></pre></td></tr></table></figure><h2 id="47、全缓冲、行缓冲、无缓冲"><a href="#47、全缓冲、行缓冲、无缓冲" class="headerlink" title="47、全缓冲、行缓冲、无缓冲"></a>47、全缓冲、行缓冲、无缓冲</h2><p><strong>全缓冲</strong>：直到缓冲区被填满，才调用系统I&#x2F;O函数。对于读操作来说，直到读入的内容的字节数等于缓冲区大小或者文件已经到达结尾，才进行实际的I&#x2F;O操作， 将外存文件内容读入缓冲区；对于写操作来说，直到缓冲区被填满，才进行实际的I&#x2F;O操作，缓冲区内容写到外存文件中。<strong>磁盘文件读写</strong>通常是全缓冲的。</p><p><strong>行缓冲</strong>：直到遇到换行符’\n’，才调用系统I&#x2F;O库函数。<br>对于读操作来说，遇到换行符’\n’才进行I&#x2F;O操作，将所读内容读入缓冲区；<br>对于写操作来说，遇到换行符’\n’才进行I&#x2F;O操作，将缓冲区内容写到外存中。<br>由于缓冲区的大小是有限的，所以当缓冲区被填满时，即使没有遇到换行符’\n’，也同样会 进行实际的I&#x2F;O操作。<br>当流涉及到一个终端时，通常使用行缓冲。<br><strong>典型代表是标准输入(stdin)和标准输出(stdout)</strong></p><p><strong>无缓冲</strong>：没有缓冲区，数据会立即读入或者输出到外存文件和设备上。标准出错stderr是无缓冲的，这样保证错误提示和输出能够及时反馈给用户，供用户排除错误。<strong>标准出错情况stderr</strong>是典型代表</p><p>1、<strong>系统调用是不带缓冲的</strong></p><p>2、<strong>stdout 和 STDOUT_FILENO 的区别</strong></p><p>使用stdin的函数主要有：fread、fwrite、fclose等，基本上都以f开头<br>使用STDIN_FILENO的函数有：read、write、close等</p><h2 id="48、TCP粘包"><a href="#48、TCP粘包" class="headerlink" title="48、TCP粘包"></a>48、TCP粘包</h2><p>在socket网络编程中，都是端到端通信，由客户端端口+服务端端口+客户端IP+服务端IP+传输协议组成的五元组可以明确的标识一条连接。在TCP的socket编程中，发送端和接收端都有成对的socket。发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。那么这样一来，接收端就必须使用高效科学的拆包机制来分辨这些数据。</p><p><strong>1.Q：什么是TCP粘包问题？</strong></p><p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾，出现粘包的原因是多方面的，可能是来自发送方，也可能是来自接收方。</p><p><strong>2.Q：造成TCP粘包的原因</strong><br>（1）发送方原因</p><p>TCP默认使用<strong>Nagle</strong>算法（主要作用：减少网络中报文段的数量），而Nagle算法主要做两件事：</p><p>只有上一个分组得到确认，才会发送下一个分组<br>收集多个小分组，在一个确认到来时一起发送<br>Nagle算法造成了发送方可能会出现粘包问题<br>（ 发送端需要等缓冲区满才发送出去，造成粘包）</p><p>（2）接收方原因</p><p>TCP接收到数据包时，并不会马上交到应用层进行处理，或者说应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接收缓存里，然后应用程序主动从缓存读取收到的分组。这样一来，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。<br>（接收方不及时接收缓冲区的包，造成多个包接收）</p><p><strong>3.Q：什么时候需要处理粘包现象？</strong><br>如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象(文件传输)<br>如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了</p><p><strong>4.Q：如何处理粘包现象？</strong></p><p>（1）发送方<br>        对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。</p><p>（2）接收方<br>        接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。</p><p>（3）应用层<br>        应用层的解决办法简单可行，不仅能解决接收方的粘包问题，还可以解决发送方的粘包问题。</p><p>解决办法：循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成，但是如何判断每条数据的长度呢？</p><p>格式化数据：每条数据有固定的格式（开始符，结束符），这种方法简单易行，但是选择开始符和结束符时一定要确保每条数据的内部不包含开始符和结束符。<br>发送长度：发送每条数据时，将数据的长度一并发送，例如规定数据的前4位是数据的长度，应用层在处理时可以根据长度来判断每个分组的开始和结束位置。</p><p><strong>5.Q：UDP会不会产生粘包问题呢？</strong></p><p>TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。</p><p>UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。</p><h2 id="49、字节流和数据报"><a href="#49、字节流和数据报" class="headerlink" title="49、字节流和数据报"></a>49、字节流和数据报</h2><p>TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的</p><p>UDP是个”数据包”协议,也就是两段数据间是有界限的,在接收端要么接收不到数据要么就是接收一个完整的一段数据,不会少接收也不会多接收.</p><h2 id="50、有哪些事件会导致创建一个进程"><a href="#50、有哪些事件会导致创建一个进程" class="headerlink" title="50、有哪些事件会导致创建一个进程"></a>50、有哪些事件会导致创建一个进程</h2><p>1 用户登录；系统为用户创建一个进程，并插入就绪队列<br>2 作业调度<br>3 提供服务 系统为用户请求创建一个进程<br>4 应用请求 用户程序自己创建进程</p><h2 id="51、-dll-so-o-a-lib-obj-文件的区别"><a href="#51、-dll-so-o-a-lib-obj-文件的区别" class="headerlink" title="51、.dll .so .o .a .lib .obj 文件的区别"></a>51、.dll .so .o .a .lib .obj 文件的区别</h2><p><strong>windows平台:</strong></p><p>.dll : 动态链接库,作为共享函数库的可执行文件.<br>.obj : 目标文件,相当于源代码对应的二进制文件,未经过重定义.<br>.lib ： 可理解为多个 obj 的集合,本质与 .obj 相同.</p><p><strong>linux平台:</strong></p><p>.so：（share object）动态链接库,和windows 的 dll 类似<br>.o : 目标文件,相当于源代码对应的二进制文件 类似 windows 下 obj.<br>.a : 与 .o 类似,多个 .o 的集合 类似 windows 下 lib.</p><h2 id="52、-CPU的管态和目态"><a href="#52、-CPU的管态和目态" class="headerlink" title="52、 CPU的管态和目态"></a>52、 CPU的管态和目态</h2><p>系统态(或称管理态，管态)和用户态(或称目态)</p><p><strong>管态</strong>，即<strong>操作系统</strong>的管理程序运行时的状态，具有较高的特权级别，也称为特权态、系统态、内核态或者核心态。当处理器处于管态时，可以执行所有的指令，包括各种特权指令，也可以使用所有的资源，并且具有改变处理器状态的能力。</p><p><strong>目态</strong>，即<strong>用户程序</strong>运行时的状态，具有较低的特权级别，又称为普通态或用户态。在这种状态下不能使用特权指令，不能直接使用系统资源，也不能改变CPU的工作状态，并且只能访问这个用户程序自己的存储空间。</p><h2 id="53、优先级反转"><a href="#53、优先级反转" class="headerlink" title="53、优先级反转"></a>53、优先级反转</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.什么是优先级反转</span><br><span class="line">简单从字面上来说，就是低优先级的任务先于高优先级的任务执行了，优先级搞反了。那在什么情况下会生这种情况呢？</span><br><span class="line">假设三个任务准备执行，A，B，C，优先级依次是A&gt;B&gt;C；</span><br><span class="line">首先：C处于运行状态，获得CPU正在执行，同时占有了某种资源；</span><br><span class="line">其次：A进入就绪状态，因为优先级比C高，所以获得CPU，A转为运行状态；C进入就绪状态；</span><br><span class="line">第三：执行过程中需要使用资源，而这个资源又被等待中的C占有的，于是A进入阻塞状态，C回到运行状态；</span><br><span class="line">第四：此时B进入就绪状态，因为优先级比C高，B获得CPU，进入运行状态；C又回到就绪状态；</span><br><span class="line">第五：如果这时又出现B2，B3等任务，他们的优先级比C高，但比A低，那么就会出现高优先级任务的A不能执行，反而低优先级的B，B2，B3等任务可以执行的奇怪现象，而这就</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2.如何解决优先级反转</span><br><span class="line"></span><br><span class="line">高优先级任务A不能执行的原因是C霸占了资源，而C如果不能获得CPU，不释放资源，那A也只好一直等在那，所以解决优先级反转的原则肯定就是让C尽快执行，尽早把资源释放了。基于这个原则产生了两个方法：</span><br><span class="line"></span><br><span class="line">2.1 优先级继承</span><br><span class="line"></span><br><span class="line">当发现高优先级的任务因为低优先级任务占用资源而阻塞时，就将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级。</span><br><span class="line"></span><br><span class="line">2.2 优先级天花板</span><br><span class="line"></span><br><span class="line">优先级天花板是指将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级.(这个优先级称为该资源的优先级天花板)</span><br><span class="line"></span><br><span class="line">2.3 两者的区别</span><br><span class="line"></span><br><span class="line">优先级继承：只有一个任务访问资源时一切照旧，没有区别，只有当高优先级任务因为资源被低优先级占有而被阻塞时,才会提高占有资源任务的优先级；而优先级天花板,不论是否发生阻塞,都提升,即谁先拿到资源，就将这个任务提升到该资源的天花板优先级。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-C&quot;&gt;&lt;a href=&quot;#C-C&quot; class=&quot;headerlink&quot; title=&quot;C&amp;#x2F;C++&quot;&gt;&lt;/a&gt;C&amp;#x2F;C++&lt;/h1&gt;&lt;h3 id=&quot;1、描述⼀下gcc的编译过程？&quot;&gt;&lt;a href=&quot;#1、描述⼀下gcc的编译过程？&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://laocaile.github.io/2024/01/21/hello-world/"/>
    <id>http://laocaile.github.io/2024/01/21/hello-world/</id>
    <published>2024-01-21T07:59:06.175Z</published>
    <updated>2024-01-21T07:59:06.175Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
